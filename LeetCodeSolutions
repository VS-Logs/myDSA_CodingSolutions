<b>LeetCode Questions:</b>
Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
Input: nums = [2,7,11,15], target = 9, Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
var twoSum = function(nums, target) {
    for(var i=0; i<nums.length; i++){
        for(var j=1; j<nums.length; j++){
            if(nums[i]+nums[j]==target){
                return [i,j] //[nums.indexOf(nums[i]),nums.indexOf(nums[j])]
            }
        }
    }    
};
------------------------------------------------------------------------------
var twoSum = function(nums, target) {
    const map = {};
    for(let i = 0; i < nums.length; i++){
        const diff = target - nums[i];
        if(map.hasOwnProperty(diff)){ //checking the new diff value is already present or not
           return [map[diff], i]; //[value, index]
		       break;
        }
        map[nums[i]] = i; //console.log(map) //we storing the exact value not diff
    }    
    return result;
};
console.log(twoSum([2,7,11,15], target = 9))
=========================================================================================================================================================================
Palindrome:
var isPalindrome = function(x) {
   if(x<0) return false;
   if(x.toString()===x.toString().split('').reverse().join('')) return true;
   return false;  
}
-------------------------------------------------------------------------------
var isPalindrome = function(x) {
   let len = x.length;
   if(x<0) return false;
    for (i=0; i<len/2;i++)
    {       
       if (x[i]!==x[len-1-i]) return false;  
    }
    return true;  
}
===========================================================================================================================================================================
Longest Common Prefix:
var longestCommonPrefix = function(strs) {
let ans = ""; var strs= strs.sort();
  for (i in strs[0]) { //i means 0,1,2
    if (!strs.every((el) => el[i] === strs[0][i])) { break; } 
      //every function return true/false usually //el representig each character of the items of 
      //an array which we are compairing with f,l,....
    ans += strs[0][i];
  }
  return ans;
};
--------------------------------------------------------------------------------
var longestCommonPrefix = function(strs) {
var arr = strs.sort()
  var i=0;
  while(arr[0].length>0 && arr[0].charAt(i)===arr[arr.length-1].charAt(i)){
    i++;
  }
  console.log(arr[0].substring(0,i)) 
  return arr[0].substring(0,i)
};
------------------------------------------------------------------------------
var longestCommonPrefix = function(strs) {
  if (strs.length === 0) return '';
  let r = '';
  for (let i = 0; i < strs[0].length; i++) {
    for (let j = 1; j < strs.length; j++) {
      if (strs[0][i] !== strs[j][i]) return r;
    }
    r += strs[0][i];
  }
  return r;
};
========================================================================================================================================================================
Valid Paranthesis :
var isValid = function(s) {
    let map ={
        "(":")",
        "{":"}",
        "[":"]"
    }
    let arr = []; //its example of stack i.e, 
    for (let ch of s){
        if(map[ch]){ //checking if inside in map object
            arr.push(map[ch]);
        }
        else if(arr.length>0 && arr[arr.length-1]===ch){ //checking length>0 otherwise give undefined
            arr.pop();
        }
        else {
            return false;
        }
    }
   return arr.length ===0 ? true: false;
};
--------------------------------------------------------------
const isValid = (s) => {
  const stack = [];
  for (const c of s) {
    if (c === '{' || c === '[' || c === '(') stack.push(c);
    else {
      const p = stack.pop(); // No need to check for empty before popping (returns undefined)
      if ((c === '}' && p !== '{') || (c === ']' && p !== '[') || (c === ')') & (p !== '(')) return false;
    }
  }
  return stack.length === 0; //true
};
=======================================================================================================================================================================
Contain duplicate: 
var containsDuplicate = function(nums) {
    return nums.length !== new Set(nums).size // As Set only contains non-duplicate values so new Set(nums) will remove all duplicates element then you can 
    //check if the lenght of the array is same as set if same means no duplicates element otherwise duplicate is there
};
---------------------------------------------------------------
var containsDuplicate = function(nums) {
    return nums.length > new Set(nums).size;
};
=========================================================================================================================================================================


