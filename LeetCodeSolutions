<b>LeetCode Questions:</b>
Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
Input: nums = [2,7,11,15], target = 9, Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
var twoSum = function(nums, target) {
    for(var i=0; i<nums.length; i++){
        for(var j=1; j<nums.length; j++){
            if(nums[i]+nums[j]==target){
                return [i,j] //[nums.indexOf(nums[i]),nums.indexOf(nums[j])]
            }
        }
    }    
};
------------------------------------------------------------------------------
var twoSum = function(nums, target) {
    const map = {};
    for(let i = 0; i < nums.length; i++){
        const diff = target - nums[i];
        if(map.hasOwnProperty(diff)){ //checking the new diff value is already present or not
           return [map[diff], i]; //[value, index]
		       break;
        }
        map[nums[i]] = i; //console.log(map) //we storing the exact value not diff
    }    
    return result;
};
console.log(twoSum([2,7,11,15], target = 9))
=========================================================================================================================================================================
Palindrome:
var isPalindrome = function(x) {
   if(x<0) return false;
   if(x.toString()===x.toString().split('').reverse().join('')) return true;
   return false;  
}
-------------------------------------------------------------------------------
var isPalindrome = function(x) {
   let len = x.length;
   if(x<0) return false;
    for (i=0; i<len/2;i++)
    {       
       if (x[i]!==x[len-1-i]) return false;  
    }
    return true;  
}
===========================================================================================================================================================================
Longest Common Prefix:
var longestCommonPrefix = function(strs) {
let ans = ""; var strs= strs.sort();
  for (i in strs[0]) { //i means 0,1,2
    if (!strs.every((el) => el[i] === strs[0][i])) { break; } 
      //every function return true/false usually //el representig each character of the items of 
      //an array which we are compairing with f,l,....
    ans += strs[0][i];
  }
  return ans;
};
--------------------------------------------------------------------------------
var longestCommonPrefix = function(strs) {
var arr = strs.sort()
  var i=0;
  while(arr[0].length>0 && arr[0].charAt(i)===arr[arr.length-1].charAt(i)){
    i++;
  }
  console.log(arr[0].substring(0,i)) 
  return arr[0].substring(0,i)
};
------------------------------------------------------------------------------
var longestCommonPrefix = function(strs) {
  if (strs.length === 0) return '';
  let r = '';
  for (let i = 0; i < strs[0].length; i++) {
    for (let j = 1; j < strs.length; j++) {
      if (strs[0][i] !== strs[j][i]) return r;
    }
    r += strs[0][i];
  }
  return r;
};
========================================================================================================================================================================
Valid Paranthesis :
var isValid = function(s) {
    let map ={
        "(":")",
        "{":"}",
        "[":"]"
    }
    let arr = []; //its example of stack i.e, 
    for (let ch of s){
        if(map[ch]){ //checking if inside in map object
            arr.push(map[ch]);
        }
        else if(arr.length>0 && arr[arr.length-1]===ch){ //checking length>0 otherwise give undefined
            arr.pop();
        }
        else {
            return false;
        }
    }
   return arr.length ===0 ? true: false;
};
--------------------------------------------------------------
const isValid = (s) => {
  const stack = [];
  for (const c of s) {
    if (c === '{' || c === '[' || c === '(') stack.push(c);
    else {
      const p = stack.pop(); // No need to check for empty before popping (returns undefined)
      if ((c === '}' && p !== '{') || (c === ']' && p !== '[') || (c === ')') & (p !== '(')) return false;
    }
  }
  return stack.length === 0; //true
};
=======================================================================================================================================================================
Contain duplicate: 
var containsDuplicate = function(nums) {
    return nums.length !== new Set(nums).size // As Set only contains non-duplicate values so new Set(nums) will remove all duplicates element then you can 
    //check if the lenght of the array is same as set if same means no duplicates element otherwise duplicate is there
};
---------------------------------------------------------------
var containsDuplicate = function(nums) {
    return nums.length > new Set(nums).size;
};
=========================================================================================================================================================================
Remove Duplicates from Sorted Array:
var removeDuplicates = function(nums) {
    let prev = null;
    const k = nums.length;
    for (let i = 0; i < k; i++) {
        if (prev === nums[i]) { //for duplicacy won't work
            continue;
        }
        prev = nums[i];
        nums.push(nums[i]); //[1,1,2,1,2]
    }
    nums.splice(0, k); //index, no. of elemnets from that index to delete the exact array
};
=========================================================================================================================================================================
Fibonacci Number:
const fib = N => {
    return (N < 2) 
        ? N 
        : fib(N-2) + fib(N-1);
};
------------------------------------------------------
const fib = n => {
    const memo = {};
    for (let i = 0; i <= n; i++)
    {
        if (i < 2)   memo[i] = i;
        else memo[i] = memo[i-2] + memo[i-1];
    }
    return memo[n];
}
------------------------------------------------------
const fib = n => {
    let arr = [0, 1];
    
    for (let i = 2; i <= n; i++) {
        arr.push(arr[i-2] + arr[i-1]);
    }
    
    return arr[n];
};
========================================================================================================================================================================
 Search Insert Position:
var searchInsert = function(nums, target) {
    for(let i=0; i<nums.length; i++) {
        if(target === nums[i] || target < nums[i]) { //  if (nums[i] >= target){
            return i
        }
    }
    
    return nums.length
};
---------------------------------------------------------------
var searchInsert = function(nums, target) {
    let start = 0;
    let end = nums.length - 1;
    while(start<=end) {
        const mid = Math.floor((start + end)/2);
        if(nums[mid] < target) {
            start = mid + 1;
        } else {
            end = mid -1;
        }   
    }
    return start;
};
console.log(searchInsert([1,2,4,5],3))
============================================================================================================================================================================
Roman To Integer:
var romanToInt = function(s) {
    const map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000};
    let num = 0;   
    for(let i = 0; i < s.length; i++) {
        const curr = map[s[i]], next = map[s[i+1]];
        if(curr < next) num -= curr;
        else num += curr;
    }
    return num;    
};
console.log(romanToInt("LVIII"))
========================================================================================================================================================================
Valid Anagram:
var isAnagram = function(s, t) {
    if (s.length !== t.length) return false;
    return s.split("").sort().join("") === t.split("").sort().join("");
};
-------------------------------------------------------------------------
function isAnagram(s, t) {
  if (s.length !== t.length) return false;

  const map = {};

  for (let c of s) {
    if (map[c] == null) map[c] = 0;
    map[c]++;
  }

  for (let c of t) {
    if (map[c] > 0) map[c]--;
    else return false;
  }

  return true;
}
console.log(isAnagram("aman", "aamn"))
=======================================================================================================================================================================
Length of Last Word:-
var lengthOfLastWord = function(s) {
    const arr = s.trim().split(' ');
    return arr[arr.length - 1].length;
};
--------------------------------------------
var lengthOfLastWord = function(s) {
   return s.trim().split(" ").pop().length;
};
------------------------------------------
var lengthOfLastWord = function(s) {
   return s.trim().split(' ').at(-1).length;
};
----------------------------------------------
var lengthOfLastWord = function(s) {
    let len = 0;
    let hasStarted = false;
    for (let i = s.length - 1; i >= 0; i--) {
        if (s[i] !== ' ') hasStarted = true;
        if (hasStarted) {
            if (s[i] === ' ') break;
            len++;
        }
    }
    return len;
};
============================================================================================================================================================================
Majority Element:
var majorityElement = function(nums) {
    let map = {}
    for(let item of nums){
        if(!map[item]) {
            map[item] = 1;
        } else {
            map[item]++;
        }
        if (map[item] >= nums.length/2) return item
    }
};
========================================================================================================================================================================
Missing Number:
var missingNumber = function(nums) {
    nums.sort((a,b) => a - b ) 
    let count = 0
    for(let i = 0; i <= nums.length; i++) { // o (n)
        if(nums[i] == count) {
           count++
        } else {
            return count
        }
    }
};
------------------------------------------------
var missingNumber = function(nums) {
   nums.sort(function(a,b){return (a-b); });
    for(let i=0;i<nums.length;i++){
        if(nums[i]!==i){
            return i;
        }
    }
    return nums.length    
};
-----------------------------------------------
var missingNumber = function(nums) {
    nums.sort((a,b)=>a-b);
    if (nums[0] !== 0) return 0;
    for (var i = 0; i < nums.length; i++) {
        if (nums[i]+1 !== nums[i+1]) {
            return i+1;
        }
    }
};
==============================================================================================================================================================================
Reverse Vowels of a String:
var reverseVowels = function(s) {
    const VOWELS = { 'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1, 'A': 1, 'E': 1, 'I': 1, 'O': 1, 'U': 1 };
    const arr = s.split('');
    let i = 0, j = arr.length - 1;
    while (i < j) {
        if (VOWELS[arr[i]] && VOWELS[arr[j]]) { //if both present in VOWELS
            [arr[i], arr[j]] = [arr[j], arr[i]];
            i++;
            j--;
        } else if (VOWELS[arr[i]]) { //if left side present in VOWELS then need to find right hand side so that's why j--
            j--;
        } else { //if right side present in VOWELS
            i++;
        }
    }
    return arr.join('');
};
----------------------------------------------------------------------------
var reverseVowels = function(s) {
    let left = 0
    let right = s.length - 1
    let arr = s.split("")
    let vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', "I", 'O', 'U']
    
    while(left < right){
        if(vowels.indexOf(arr[left]) !== -1 && vowels.indexOf(arr[right]) !== -1) // if both present in vowels
            {
                [arr[left], arr[right]] = [arr[right], arr[left]]
                ++left;
                --right;
            }
        if(vowels.indexOf(arr[left]) == -1){ //if left not present
            ++left
        }
        if(vowels.indexOf(arr[right]) == -1){ //if right not prsent
            --right
        }
    }
    return arr.join("")
};
------------------------------------------------------------------------------------
const reverseVowels = (s) => {
    const vowels = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);
    s = s.split('');
    
    let l = 0, r = s.length - 1;
    
    while(l < r){
        if(vowels.has(s[l]) && vowels.has(s[r])){
            swap(s, l, r);
            l++, r--;
        }else if(!vowels.has(s[l])){
            l++;
        }else if(!vowels.has(s[r])){
            r--;
        }
    }
    
    return s.join('');
};

const swap = (arr, l, r) => {
    const temp = arr[l];
    arr[l] = arr[r];
    arr[r] = temp;
}
--------------------------------------------------------------------------
function swap(arr, idx1, idx2) {
    return [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
}

// reverse vowel function
var reverseVowels = function(s) {
    let vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];
    s = s.split('');
    let start = 0;
    let end = s.length-1;
    while(start < end) {
        if(vowels.includes(s[start]) && vowels.includes(s[end])) {
            swap(s, start, end);
            start++;
            end--;
        }else if(!vowels.includes(s[start])){
            start++;
        } else if(!vowels.includes(s[end])) {
            end--;
        }
    }
    
    return s.join('');
};
================================================================================================================================================================================
Single Number:
var singleNumber = function(nums) {
            nums.sort();
            for (var i = 0; i < nums.length; i += 2) {
                if (nums[i] != nums[i + 1]) {
                    return nums[i];
                }
            }
};
-----------------------------------------
var singleNumber = function(nums) {
    let hash = {}
    for(let val of nums){
        hash[val]?delete hash[val]:hash[val]=1;
    }
    return Object.keys(hash)[0]
};
-----------------------------------------------
var singleNumber = function(nums) {
    for(var i=0;i<nums.length;i++) {
        if(nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])) return nums[i];
    }
};
===============================================================================================================================================================================
Fizz Buzz:
var fizzBuzz = function (n) {
  const result = [];
  for (let i = 1; i <= n; i++) {
    if (i % 5 === 0 && i % 3 === 0) result.push("FizzBuzz");
    else if (i % 3 === 0) result.push("Fizz");
    else if (i % 5 === 0) result.push("Buzz");
    else result.push(i.toString());
  }
  return result;
};
---------------------------------------------------------
var fizzBuzz = function (n) {
return new Array(n).fill(0).map((item, num) => (++num % 3 ? '' : 'Fizz') + (num % 5 ? '' : 'Buzz') || '' + num);
};

->My first thought is to use the Array constructor. If you pass an integer as the only argument, an empty array with the given length is returned.
-> for loop that goes from 0 — 100
-> This code makes use of the ternary operator(condition ? value if true : value if false).
-> The condition that we’re testing is ++i%3. 
    If that is true, then '' will be returned. 
    If ++i%3 is false, then fizz will be returned.
-> For ++i%3, the increment operator is being used. Using the operator before the operand ++i will increment the operator i before returning it. This means that on our first pass through the loop, i will increase from 0 to 1.
-> For 1 % 3, utilizes the remainder operator. The remainder operator returns the remainder of one number divided another.
-> The remainder is 1 and thus our ternary condition is now simplified to 1.
-> 1 ends up not being a falsy value and therefor coerces into a truthy value.
========================================================================================================================================================================
Concatenation of Array:
var getConcatenation = function(nums) {
    return nums.concat(nums)
};
--------------------------------------------------
var getConcatenation = function(nums) {
   return [...nums, ...nums]
};
--------------------------------------------------
var getConcatenation = function(nums) {
    var n = nums.length;
   for(var i=0; i<n; i++){
       nums[i+n]=nums[i]
   }
    return nums
}
--------------------------------------------------
var getConcatenation = function(nums) {
    let n = nums.length;
    let ans = new Array(2*n);    
    for(let i = 0; i < n; i++) {
		// ans[i] == nums[i] and ans[i + n] == nums[i]
        ans[i] = ans[i + n]= nums[i];
    }
    return ans;
};
=========================================================================================================================================================================
Sort Array By Parity: 
var sortArrayByParity = function(nums) {
    var even =[], odd=[];
    for(var i=0; i<nums.length;i++){
        if(nums[i]%2 ===0){ even.push(nums[i]) }  
        else {odd.push(nums[i])}
    }
    return even.concat(odd);
};
-----------------------------------------------------------
var sortArrayByParity = function(nums) {
    var even = nums.filter(num => num%2 === 0)
    var odd = nums.filter(num => num%2 !==0)
    return even.concat(odd);
}
------------------------------------------------------------
var sortArrayByParity = function(nums) {
    var even =[], odd=[];
    nums.forEach((item)=>{
         item%2==0 ? even.push(item) : odd.push(item)
        
    })
    return even.concat(odd)
}
---------------------------------------------------------------
var sortArrayByParity = function(nums) {
    var even =[], odd=[];
    nums.forEach((item)=>{
         item%2==0 ? even.push(item) : odd.push(item)        
    })
    return [...even, ...odd]
}
-------------------------------------------------------------
var sortArrayByParity = function(nums) {
    var temp =[]
    nums.forEach((item)=>{
         item%2==0 ? temp.unshift(item) : temp.push(item)        
    })
    return temp
}
-----------------------------------------------------------
var sortArrayByParity = function(A) {
    return [...A.filter(v => v % 2 === 0), ...A.filter(v => v % 2 !== 0)];
};
-----------------------------------------------------------
var sortArrayByParity = function(A) {
  let i = 0;
  let j = A.length -1;

  while(i < j) {
    if (A[i] % 2 !== 0 && A[j] % 2 === 0) {
      let temp = A[i];
      A[i] = A[j];
      A[j] = temp;
    }

    if (A[i] % 2 !== 0) {
      j--;
    }

    if(A[i] % 2 === 0) {
      i++;
    }
  }

  return A;
};
=========================================================================================================================================================================
String Compression: 
/*var compress = function(chars) {
    var arr=[], count=1;
    //if(chars.length===1) return 1;
    for(var i=0; i< chars.length; i++){
        if(!arr.includes(chars[i])){arr.push(chars[i])}
        if(chars[i] != chars[i+1]){
            arr.push(count);
          count =1;
        }
        if(chars[i]==chars[i+1]){
            count++;
        }
    }
    return arr.length;
};
//console.log(compress( ["a","b","b","b","b","b","b","b","b","b","b","b","b"]))
*/
------------------------------------------------------------------
var compress = function(chars) {
    var arr=[], count=1;
    if(chars.length===1) return 1;
    for(var i=0; i< chars.length; i++){
        if(!arr.includes(chars[i])){arr.push(chars[i])}
        if(chars[i] != chars[i+1]){
            arr.push(""+count);
          count =1;
        }
        if(chars[i]==chars[i+1]){
            count++;
        }
    }
    return arr.length;
};
console.log(compress( ["a","b","b","b","b","b","b","b","b","b","b","b","b"]))
======================================================================================================================================================================================
Find All Numbers Disappeared in an Array:
var findDisappearedNumbers = function(nums) {
    var s = {};
    for (let i =1; i<= nums.length; i++) {
        s[i] = 1; //storing all the key and values(1) to the object till the length of an array
    }    
    nums.forEach(n=> {   delete s[n] })  //deleting if we have in nums
   return Object.keys(s) //getting from an object
}; console.log(findDisappearedNumbers([4,3,2,7,8,2,3,1]))
-------------------------------------------------------------------
To find unique values:
var kthDistinct = function(arr) {
  var unique = []
  arr.filter((item)=>{
    if(!unique.includes(item))
       {
         unique.push(item)
       }
    else {
        unique.splice(1,1)
    }
  })
 
  return unique
};
console.log(kthDistinct(["d","b","c","b","c","a"])) //[d,a]
=====================================================================================================================================================================
 Kth Distinct String in an Array: 
var kthDistinct = function(arr,k) {
  var unique = []
  arr.filter((item)=>{
    if(!unique.includes(item))
       {
         unique.push(item)
       }
    else {
        unique.splice(1,1)
    }
  })
 
  return unique[k-1] == undefined ? "" : unique[k-1]
   
};
//console.log(kthDistinct(["d","b","c","b","c","a"],2))*/
-------------------------------------------------------------------------------
var kthDistinct = function(arr, k) {
    let obj = {}
    let ans = []
    
    for (let item of arr) {
        obj[item] = obj[item] + 1 || 1
    } // arr.forEach(letter => map[letter] = map[letter] + 1 || 1)
    
    for (let item in obj) {
        if (obj[item] === 1) {
            ans.push(item)   
        }
    }
    
    return ans.length >= k ? ans[k-1] : ''
    
    
};
-------------------------------------------------------------------------------
const kthDistinct = (arr, k) => {
    const map = {}
    
    for (const word of arr) {
        if (!(word in map)) map[word] = 0
        
        map[word]++
    }

    const distinct = arr.filter(word => map[word] === 1)
    
    return distinct[k - 1] || ''
}
-------------------------------------------------------------------------------
const kthDistinct = (arr, k) => {
  const notDistinct = new Set(arr.filter((x, index, arr) => arr.indexOf(x) !== arr.lastIndexOf(x)));
  return arr.filter((x) => !notDistinct.has(x))[k - 1] ?? "";
};
-------------------------------------------------------------------------------
var kthDistinct = function(arr, k) {
    let freqs = {};
    for (let s of arr) freqs[s] = (freqs[s] || 0) + 1;
       
    return [...Object.keys(freqs)].filter(x => freqs[x] === 1)[k - 1] || "";
};
======================================================================================================================================================================
Merge Strings Alternately:
var mergeAlternately = function(word1, word2) {
    var merged = [];
    var w1 = word1.split("");
    var w2 = word2.split("");
    for(var i=0; i<word1.length || i< word2.length; i++){
        merged.push(word1[i])
        if( word2[i]){
            merged.push(word2[i])
        }
    }
    return merged.join("")
};
console.log(mergeAlternately("abc","pqr"))
============================================================================
Divide a String Into Groups of Size k: 
var divideString = function(s, k, fill) {
    var result = []
    for(let i = 0;i<s.length;i+=k){
		const element = s.slice(i,i+k);
		if(element.length === k){
			result.push(element);
		}
		else {
			result.push(element+ fill.repeat(k - element.length));
			
		}
	}
	return result;
};
--------------------------------------------------------
var divideString = function(s, k, fill) {
    const res = []; let str = '';
    for (let i = 0; i < s.length; i++) {
        str += s[i];  
        if (str.length === k) {
            res.push(str);
            str = '';
        }
    }
    const n = str.length;   
    if (n > 0) {
        for (let i = 0; i < k - n; i++) {
            str += fill;
        }    
        res.push(str);
    }   
    return res;
};
console.log(divideString("abcdefghi", 3, "x"))
----------------------------------------------------------------
var divideString = function(s, k, fill) {
    let result = []    
    if(s.length % k !== 0) s = s.concat(fill.repeat(k - s.length % k))   
    for(let i = 0; i < s.length; i += k){
        result.push(s.slice(i,i+k))
    } 
    return result
};
------------------------------------------------------------------
const divideString = (s, k, fill) => {
  const result = []
  if (s.length % k) {
    s += fill.repeat(k - s.length % k)
  }
  for (let i = 0; i < s.length; i ++) {
    result.push(s.slice(i, i + k))
    i += k - 1
  }
  return result
}
=========================================================================================================================================================================
Plus One : 
var plusOne = function(digits) {
for(var i = digits.length - 1; i >= 0; i--){
     digits[i]++; 
    if(digits[i] > 9){
        digits[i] = 0;
    }else{
        return digits;
    }
}
digits.unshift(1);
return digits;
}; [1,2,3] //[1,2,4]
//First, I add 1 anyway. If there is a carry-over, the new digit will also add 1. If the current digit is less than 9 then return the array.
//Last, when running over for loop, I just put fill 1 in front of the array.
//the spread operator creates a copy while unshift manipulates the original array.
--------------------------------------------------------
var plusOne = function(digits) {
  for(let i = digits.length - 1; i >= 0; i --){
    if(digits[i] === 9){
      digits[i] = 0;
    }
    else {
      digits[i] ++;
      return digits; //if less than 9
    }
  }
  return [1,...digits] //[1, ...digits] is the equivalent of digits.unshift(1) //Always run for more than 9
  //this is used for the case where the digits are [9,9] after the iteration has //been completed, we are left with [0,0] which is wrong but it's okay because at //this point what we do is only increasing the number by one. So if this happens, //how do we return the right answer? We return the array with appending 1 in the //front and spread the digits to make a new array of [1,0,0]  
};
--------------------------------------------------
var plusOne = function(digits) {
    if (!digits || digits.length == 0) return [];
    for(let i = digits.length - 1; i >= 0; i--){
        if (digits[i] < 9){ //998->999  989->990
            digits[i]++;
            return digits;
        }
        else{
            digits[i] = 0;
        }
    }
    //only special case 999-> 1000
    let thousand = new Array(digits.length).fill(0);
    thousand.unshift(1); //add 1 in head of arr
    return thousand;
};
----------------------------------------------------------
var plusOne = function(digits) {
    let end = digits.length - 1;
    for(let i = end; i >= 0; i--){
        if(digits[i] !== 9){
            digits[i] = digits[i] + 1;
            break;
        } else {
            digits[i] = 0;
        }
    }

    if(digits[0] === 0) digits.unshift(1);
    return digits;
};
==========================================================================================================================================================================
Find First Palindromic String in the Array:
var firstPalindrome = function(words) {
    for(var i =0; i<words.length; i++){
        if(words[i] === words[i].split('').reverse().join('')){
           return words[i];
           break;
        }
    }
    return ""
};
----------------------------------------------------------------------
var firstPalindrome = function(words) {
    for (const word of words) {
        if (word === word.split('').reverse().join('')) return word;
    }
    
    return '';
}; 
----------------------------------------------------------------------
var firstPalindrome = function(words) {
    const isPalindrome = (w) => {
        if(w === w.split('').reverse().join('')) return true
        return false;
    }
    
    let result = words.find(word => isPalindrome(word));
    if(result) return result;
    return '';
};
----------------------------------------------------------------------
var firstPalindrome = function(words) {    
    let result = words.find(w =>w === w.split('').reverse().join('') ?  true :   false)
    return result ? result : '';
};
----------------------------------------------------------------------
const firstPalindrome = (words) => words.find((x) => x === [...x].reverse().join("")) ?? "";
----------------------------------------------------------------------
var firstPalindrome = function(words) {
    const palindrome = words.filter(item => item == item.split("").reverse().join(""));
    if (palindrome.length > 0){
      return palindrome[0];
    }
    return ""
}; 
----------------------------------------------------------------------
var firstPalindrome = function(words) {
  let reverseArr = []
   for(let i=0; i<words.length; i++){
       reverseArr.push(words[i].split('').reverse().join(''));
       if(reverseArr[i] == words[i]){
           return reverseArr[i]
       }
   }
   return ''
};
//console.log(firstPalindrome(["abc","car","ada","racecar","cool"])) //"ada"
=============================================================================================================================================================================
Count of Smaller Numbers After Self
var countSmaller = function(nums) {
    let newNums = [...nums];
    newNums.sort(function(i1, i2){return i1 - i2});    
    let res = [];
    for(let i = 0; i < nums.length; ++i){
        let seq = newNums.indexOf(nums[i]);
        res.push(seq);
        newNums.splice(seq, 1);
    }   
    return res; 
};
//console.log(countSmaller([5,2,6,1])) //[2,1,1,0]
----------------------------------------------------------
var countSmaller = function(nums) {
    if (nums.length === 0) return nums
    const retVal = []
    for (let i = 0; i < nums.length; i++) { // 1
        for (let j = 0; j < i; j++) { // 0
            if (nums[j] > nums[i]) { // 0 1
                retVal[j] += 1
            }
        }
        retVal.push(0)
    }
    return retVal;
};
===========================================================================================================================================================================
Add Strings:
var addStrings = function(num1, num2) {
    if(num1.length === num2.length){
    var result = (parseInt(num1)+parseInt(num2)).toString();}
    return result;
};
//console.log(addStrings("11", "123")) //"134"
----------------------------------------------------------------------------------
var addStrings = function(num1, num2) {
    var cast1 = num1 * 1
    var cast2 = num2 * 1
    var answer = cast1 + cast2;  
    return ''+answer;
};
----------------------------------------------------------------------------------
var addStrings = function(num1, num2) {
  const sum = BigInt(num1) + BigInt(num2);
  return sum.toString();
};
----------------------------------------------------------------------------------
var addStrings = function(num1, num2) {
    let len = num1.length>num2.length ? num1.length:num2.length;
    let l1 = num1.length-1, l2 = num2.length-1;
    let carry = 0, out = "", sum = 0;
    for(let i = 0; i<len; i++){
        sum = parseInt(num1[l1-i] || 0) + parseInt(num2[l2-i] || 0) + carry;
        out = sum%10 + out;
        carry = Math.floor(sum/10);
    }
    if(carry>0) out = carry+out;
    return out;
};
------------------------------------------------------------------------------------
var addStrings = function(num1, num2) {
    let result = "";
    let carry = 0;
    let p1 = num1.length - 1;
    let p2 = num2.length - 1;
    while(p1 >= 0 || p2 >= 0) {
        const x1 = p1 >= 0 ? (num1.charCodeAt(p1) - '0'.charCodeAt(0)) : 0;
        const x2 = p2 >= 0 ? (num2.charCodeAt(p2) - '0'.charCodeAt(0)) : 0;
        const value = (x1 + x2 + carry) % 10;
        carry = Math.floor((x1 + x2 + carry) / 10);
        result = value + result;   
        p1--;
        p2--;
    }
    if (!!carry) { result = carry + result}    
    return result;
};
==========================================================================================================================================================================
Find First and Last Position of Element in Sorted Array
function searchRange(nums, target) {
  return [nums.indexOf(target), nums.lastIndexOf(target)];
}
---------------------------------------------------------------
const searchRange = function(nums, target) {
	let index = nums.indexOf(target)

	if (index > -1) {
		let start = index
		let end = index
		while(nums[index] === nums[index + 1]) {
			end++
			index++
		}

		return [start, end]
	}

	return [-1, -1]
};
------------------------------------------------------------------
function binarySearch(nums, target, findMaxIndex) {
    let index = -1, start = 0, end = nums.length - 1;
    
    while (start <= end) {
        const mid = Math.floor(start + (end - start) / 2);
        if (target < nums[mid]) {
            end = mid - 1;
        } else if (target > nums[mid]) {
            start = mid + 1;
        } else {
            index = mid;
            if (findMaxIndex) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
    }
    
    return index;
}
var searchRange = function(nums, target) {
    const result = [-1, -1];
    
    result[0] = binarySearch(nums, target, false);
    if (result[0] > -1) {
        result[1] = binarySearch(nums, target, true);
    }
    
    return result;
};
---------------------------------------------------
var searchRange = function(nums, target) {
    var result = []
    for(var i=0; i<nums.length; i++){
        if(nums.length ==1 && nums[i]==target){
           return [0,0];
        }
        if(nums[i]===target){
         result.push(i)   
        }
    }
    return result.length ? result : [-1,-1];
};
//console.log(searchRange([5,7,7,8,8,10], 8)) //not worked for all test cases
=======================================================================================================================================================================
 Find the Difference:
 /**
 * @param {string} s
 * @param {string} t
 * @return {character}
 */
var findTheDifference = function(s, t) {
    return [...t].sort().find((char, i) => char !== [...s].sort()[i])
}; //s="abc", t="abcd"
/*var findTheDifference = function(s, t) {
    var sChars = s.split('').sort();
    var tChars = t.split('').sort();
    var i;
    for(i = 0; i < sChars.length; i++) {
        if(tChars[i] !== sChars[i]) {
            return tChars[i];
        }
    }
    return tChars[i];
};*/
/*var findTheDifference = function (s, t) {
    for (let i = 0; i < s.length; i++) {
        t = t.replace(s[i], '')
    }
    return t;
};*/
/*var findTheDifference = function(s, t) {
    for (let letter of s)
        t = t.replace(letter, '');
    return t;
};*/
/*var findTheDifference = function(s, t) {
  const sum1 = s.split('').reduce((acc, cur) => acc + cur.charCodeAt(0), 0);
  const sum2 = t.split('').reduce((acc, cur) => acc + cur.charCodeAt(0), 0);
  return String.fromCharCode(sum2 - sum1);
};*/


/*var findTheDifference = function(s, t) {
  var s = s.split("").sort((a,b)=> a-b).join(""); 
  var t = t.split("").sort((a,b)=> a-b).join("");
 // console.log(s,t)
  for(var i =0; i< t.length || s.length; i++){
      if(s[i] != t[i]){
          return t[i]
      }
  }
};
console.log(findTheDifference( "abcd", "abcde"))*/
====================================================================
String Matching in an Array:
var stringMatching = function(words) {
    words.sort((a, b) => a.length - b.length)
    const result = []
    
    for(let i=0; i<words.length; i++) {
        const currentWord = words[i]
        
        for(let j=i+1; j<words.length; j++) {
            if(words[j].includes(currentWord)) {
                result.push(currentWord)
                break
            }
        }
    }
    
    return result
};
/*var stringMatching = function(words) {
    let arr = []
    for(let i=0; i<words.length; i++){
       for(let j=0; j<words.length; j++){
        if(words[i] != words[j] && words[i].includes(words[j])){
            arr.push(words[j])
        }           
       }
    }
    let newArr = [...new Set(arr)]   // removed duplicate elements
    return newArr
};
/*var stringMatching = function(words) {
    let str = '';
    words.sort((a, b) => a.length - b.length);
    let res = [];
    for (let i = words.length - 1; i >= 0; i--) {
        if (str.includes(words[i])) res.push(words[i]);
        else str += words[i];
    } 
    
    return res;
};
/*const stringMatching = words =>
  words.filter(n => words.some(h => h !== n && h.includes(n)));
/*var stringMatching = function(words) {
    let res = [];
    for (let word of words){
        if (words.filter(w => w.includes(word)).length > 1) res.push(word);
    }
    return res;
};*/

//consle.log(stringMatching(["mass","as","hero","superhero"]))
========================================================================================================================================================================
Reorganize String:
var reorganizeString1 = function(S) {
    let hash = {};
    for (let c of S) hash[c] = hash[c] + 1 || 1;

    let sort = Object.keys(hash).sort((a,b)=>hash[b] - hash[a]);
    let res = [];
    let index = 0;

    for (let i = 0;i<sort.length;i++) {
        let occur = hash[sort[i]];
        if (occur > parseInt((S.length + 1)/2)) return "";
        for (let j = 0;j < occur;j++) {
            if (index >= S.length) index = 1;
            res[index] = sort[i];
            index += 2;
        }
    } 
    return res.join('');
};
console.log(reorganizeString("aab")) //"aba"
======================================================================================================================================================================
Longest Substring Without Repeating Characters: 
We can use the Sliding Window technique for this question. Sliding Window is good for analysing subsets within a data structure, to see which subset is the best. 
There are two approaches; fixed sized and dynamic. This solution uses the dynamic approach where the window is not a fixed size and can grow and shrink.
Sliding Window uses two pointers to define the boundary of the subset (this is the window). In this example left and i are the left and right pointers, respectively.
To solve the problem of finding the longest unique substring we use Set to store the characters. Before adding to the Set we first check if it already exists. 
If it does exist, we remove all the characters in the Set from the left (using our left pointer) until the duplicate character has been removed.

const lengthOfLongestSubstring = s => {
 //sliding window approach
 if(!s){return 0}
 let start=0, end=0;
 const uniqueCharacter = new Set();
 let maxLength=0;
 while(end<s.length){
     if(!uniqueCharacter.has(s[end])){
         uniqueCharacter.add(s[end]);
         end++;
         //maxLength = Math.max(maxLength, uniqueCharacter.size)
         maxLength = Math.max(maxLength, end - start )
     }
     else{
         uniqueCharacter.delete(s[start]);
         start++;
     }
 }
 return maxLength;
}
---------------------------------------
USING MAP:
var lengthOfLongestSubstring = function(s) {
    // keeps track of the most recent index of each letter.
    const seen = new Map();
    // keeps track of the starting index of the current substring.
    let start = 0;
    // keeps track of the maximum substring length.
    let maxLen = 0;
    
    for(let i = 0; i < s.length; i++) {
        // if the current char was seen, move the start to (1 + the last index of this char)
        // max prevents moving backward, 'start' can only move forward
        if(seen.has(s[i])) start = Math.max(seen.get(s[i]) + 1, start)
        seen.set(s[i], i);
        // maximum of the current substring length and maxLen
        maxLen = Math.max(i - start + 1, maxLen);
    } 
    
    return maxLen;  
};
---------------------------------------------------------------
using map:
const lengthOfLongestSubstring = (s) => {
    let tempMax = 0 
    let maxLen = 0;
    const map = new Map();     
    for(let i = 0; i < s.length; i++) { 
        const char = s[i];
        if (map.get(char) >= tempMax) { 
            tempMax = map.get(char) + 1; 
        }
        map.set(char, i); 
        maxLen = Math.max(maxLen, i - tempMax + 1) 
    }
    return maxLen
}
console.log(lengthOfLongestSubstring("abcabcbb"))

OR-----------------------------
const lengthOfLongestSubstring = (s) => {
    // reference to what is needed to update maxLen
    let tempMax = 0 
    // initalize at 0 
    let maxLen = 0;
    // use Map data structure due to ease of .get() and .set() methods 
    const map = new Map();   
  
    for(let i = 0; i < s.length; i++) { 
        const char = s[i]; 
      
        // check to see if character has been encountered before. if so, and the index was equal to or greater than the current tempMax, reset tempMax to index it was seen plus 1. 
        // important because if the index it was last seen is less than tempMax that means tempMax isn't incremented up, making it easier to use it to update our maxLen below
        // if it was encountered at a high index that means it will be harder to increase our maxLen since there is a repeat character pretty close to the current character
        // new characters don't result in tempMax being increased since the lookup returns undefined which will return false for the evaluation
        // this makes it easy for maxLen to be increased since that calculation looks at the index we are currently at which will always be pretty high since the loop always moves right
        if (map.get(char) >= tempMax) { 
            tempMax = map.get(char) + 1; 
        }

        // always update the index number we saw a character in the map 
        map.set(char, i); 
      
        // use tempMax to determine to update maxLen or not. adding 1 here offsets the addition of 1 when tempMax is recalculated
        // its used to determine if adding the current character is to our advantage or not as tempMax holds a reference to how far away our last repeat is
        // subtracting current index from how far away last repeat gives us that difference and the 1 says to update or not. note it has to be greater for it to be worth updating
        maxLen = Math.max(maxLen, i - tempMax + 1) 
    }

    return maxLen
}
=======================================================================================================================================================================

maxLength tracks the largest substring, after each iteration we set maxLength to itself or the size of the Set which ever is largest.
=======================================================================================================================================================================
Longest Palindromic Substring: 
var longestPalindrome = function(s) {
    let maxPal = '';
    
    for(let i = 0; i < s.length; i++) {
        bubble(i, i); // odd palindrome
        bubble(i, i+1); // even palindrome
    }
    
    function bubble(left, right) {

        while(left >= 0 && s[left] === s[right]) {
            left--;
            right++;
        }
        left++;
        right--;
        
        if(maxPal.length < right-left+1) {
            maxPal = s.slice(left, right+1)
        }
    }
    return maxPal;
};
---------------------------------------------------------------
var longestPalindrome = function(s) {
    let maxSub = '';
    
    const bubbleFromCenter = (left, right) => {
        while(left >= 0 && right < s.length && s[left] === s[right]) {
            left--;
            right++;
        }
        return s.slice(left+1, right)
    }
    
    for(let i = 0; i < s.length; i++) {
        const sub1 = bubbleFromCenter(i, i);
        const sub2 = bubbleFromCenter(i, i+1);
        const sub = sub1.length > sub2.length ? sub1 : sub2
        if(sub.length > maxSub.length) {
            maxSub = sub
        }
    }
    return maxSub
};
-----------------------------------------------------
var longestPalindrome = function(s) {
    let wonder = "";
    if (s === null || s.length === 0) return wonder;
    for (let i = 0; i < s.length; i++) {
        let tmpOne = calc(s, i, i);
        let tmpTwo = calc(s, i, i + 1);
        wonder = tmpOne.length > wonder.length ? tmpOne : wonder;
        wonder = tmpTwo.length > wonder.length ? tmpTwo : wonder;
    }
    return wonder;
};
    const calc = (s, left, right) => {
    while (left >= 0 && right < s.length && s[left] === s[right]) {
        left--;
        right++;
    }
    return s.substring(left + 1, right);  
};
---------------------------------------------------------------------
var longestPalindrome = function(s) {
    if(s.length<1 || s === null) return '';
    var longest = '';
    for(let i=0; i<s.length; i++){
        var oddCharacters = expandFromMid(s,i,i);
        var evenCharacters = expandFromMid(s,i-1, i);
        if(oddCharacters.length> longest.length){
            longest = oddCharacters
        }
        if(evenCharacters.length> longest.length){
            longest = evenCharacters
        }
    }
    return longest
};

const expandFromMid =(s, left, right)=>{
    var i=0;
    while(s[left-i] && s[left-i]===s[right+i]){
        i++;
    }
    i--;
   return s.slice(left-i, right+i+1)
}
//console.log(longestPalindrome("babad"))*/
=======================================================================================================================================================================
Valid Parentheses: 
var isValid = function(s) {
    if (s.length <=1) return false   
    let stack = []
    let hash = {
        '(' : ')',
        '[' : ']',
        '{' : '}'
    }  
    
   /* for(let i = 0; i < s.length; i++){
        if (hash[s[i]]) stack.push(hash[s[i]]) //s[i] means { //hash[s[i]] means }
        else if (s[i] !== stack.pop()) return false
    }
    return stack.length===0 ? true : false;*/
 
 
    /*for (let i = 0; i < s.length; i++) {
    if (s[i] === '(' || s[i] === '{' || s[i] === '[') {
      stack.push(s[i]);    
    } else if (hash[stack.pop()] !== s[i]) {
      return false;
    }
  }
  return stack.length ? false : true;*/


 /*for(const char of s) {
      if (char in hash) {
      stack.push(char);    
    } else if (hash[stack.pop()] !== char) {
      return false;
    }
  }
  return !stack.length */


  for (const c of s) {
    if (c === '{' || c === '[' || c === '(') stack.push(c);
    else {
      const p = stack.pop(); // No need to check for empty before popping (returns undefined)
      if ((c === '}' && p !== '{') || (c === ']' && p !== '[') || (c === ')') & (p !== '(')) return false;
    }
  }
  return stack.length === 0;


};
console.log(isValid("{}[]"))
============================================================================================================================================================================
Move Zeroes:
var moveZeroes = function(nums) {
 return  nums.sort((a,b)=> b-a)
};
console.log(moveZeroes([0,1,0,3,12])) //[12,3,1,0,0] //Don't prefer
------------------------------------------------
var moveZeroes = function(nums) {
 const nonEmpty =[], empty=[];
  for(var i=0; i< nums.length; i++){
    if(nums[i]!==0) nonEmpty.push(nums[i]);
    else empty.push(nums[i])
  }
 return nonEmpty.concat(empty); //[...nonEmpty, ...empty]
};
console.log(moveZeroes([0,1,0,3,12]))
-----------------------------------------------------
var moveZeroes = function(nums) {
  let j = 0  // nonzero count
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {	  
      [nums[j], nums[i]] = [nums[i], nums[j]] // swap elements
      j++
    }
  }
  return nums
};
console.log(moveZeroes([0,1,0,3,12]))
------------------------------------------------------
let moveZeroes = function(nums) {
        for(let i= nums.length-1; i>=0; i--){
            if(nums[i]===0){
                nums.push(0) //adding at last
                nums.splice(i,1) //removing that element
            }
        }
        return nums
    };
console.log(moveZeroes([10,1,0,3,12]))
---------------------------------------------------
const moveZeroes = function (numbers) {

   const nonZeroNumbers = numbers.filter(number => number !== 0);

   const amountOfZeros = numbers.length - nonZeroNumbers.length;

   nonZeroNumbers.push(...Array(amountOfZeros).fill(0))

   return nonZeroNumbers;

}
console.log(moveZeroes([0,1,0,3,12]))
====================================================================================================================================================================
Valid Palindrome:
var isPalindrome = function(s) {
    s = s.replace(/[^0-9a-zA-Z]+/gmi,""); //m means	Multiline: Anchor meta characters work on each line.
    s = s.toLowerCase();
    var l = 0, r = s.length - 1;
    console.log(s);
    while(l<r) {
        if(s.charAt(l) != s.charAt(r)) {
            return false;
        }
        l++;
        r--;
    }
    return true;
};
------------------------------------------------------------
var isPalindrome = function(s) {
    s = s.replace(/[^A-Za-z0-9]/g, '').toLowerCase(); 
    //[] means contain characters
    //^ means opposite
    // A-Za-z0-9 means All the characters in a-z, A-z, 0-9
    // g means global modifier 'g' to the regex to get all the matches
    for (let i = 0; i < s.length; i++) {
        if (s[i] !== s[s.length - 1 - i]) return false;
    }
    return true;
};
console.log(isPalindrome("A man, a plan, a canal: Panama"))// true
---------------------------------------------------------------
var isPalindrome = function(s) {
   // \w means	Matches alphanumeric characters: [a-zA-Z0-9_] 
   // \W	Matches non-alphanumeric characters: [^\w]
    s = s.replace(/[\W_]+/g,"");
    s = s.toLowerCase();
    var l = 0, r = s.length - 1;
  

    while(l<r) {
        if(s.charAt(l) != s.charAt(r)) {
            return false;
        }
        l++;
        r--;
    }
    return true;
}
------------------------------------------------------------------------
var isPalindrome = function(s) {
    // | means Alternation Matches either the characters before or the characters after the symbol.
    var strippedString = s.replace(/\W|_/g, '');
    var reversedString = strippedString.split('').reverse().join('');
    
    return strippedString.toLowerCase() == reversedString.toLowerCase();
};
------------------------------------------------------------------------------
var isPalindrome = function(str) {
    let s = str.toLowerCase().split('')
    for(let i=0;i<s.length;i++){
        if((s[i].charCodeAt(0) < 97 || s[i].charCodeAt(0) > 122) && (s[i].charCodeAt(0) < 48 || s[i].charCodeAt(0) > 57)){
            s[i]=' '
        }
    }
    let newS = ''
    for(let i=0;i<s.length;i++){
        if(s[i] !== ' '){
            newS+=s[i]
        }
    }
    return newS === newS.split('').reverse().join('')
};
===============================================================================================================================================================================
Subsets:    //https://www.youtube.com/watch?v=4paR1cZx9Tg&t=650s
var subsets = function(nums) {
    let res = []
    let subsets = []
	
    const dfs = (i) => {
        if (i >= nums.length) {
           res.push(subsets.slice()) 
           return
        }
        
        //include
        subsets.push(nums[i])
        dfs(i + 1)        
        subsets.pop()
        
        //exclude
        dfs(i + 1)
    }
	
    dfs(0)
    return res
};
-------------------------------------------------------------------------------------------
var subsets = function(nums) {
    let res = [[]];
    for (const num of nums) {
        const newRes = [];
        for (const sol of res) {
           newRes.push([...sol, num])
        }
        res = [...res, ...newRes];
    }
    
    return res;
};
-------------------------------------------------------------------------------------------
const subsets = nums => {
    let res = [[]],
        curr;
    for(let num of nums) {
        curr = res.map(x => [...x, num]);
        res = [...res, ...curr]; //addition of 2 arrays i.e res with curr
    }
    return res;
};
-------------------------------------------------------------------------------------------
var subsets = function (nums) {
	let finalOutput = [];
	const helper = (currentIndex, set) => { //0, []
		if (currentIndex >= nums.length) {
			finalOutput.push(set);
			return; 
		}
		helper(currentIndex + 1, [...set, nums[currentIndex]]);
        helper(currentIndex + 1, set);
	};
	helper(0, []);
	return finalOutput;
};
-------------------------------------------------------------------------------------------
var subsets = function(nums) {
    return nums.reduce((sets, num) => sets.forEach(set => sets.push([...set, num])) || sets, [[]]);
};
-------------------------------------------------------------------------------------------
var subsets = a => a.reduce((s, l) => s.concat(s.map(t => t.concat(l))), [[]]);
-------------------------------------------------------------------------------------------
var subsets = function(nums) {
    let result = [];
    dfs([], 0);    
    function dfs(current, index){
        result.push(current);
        for(let i = index; i < nums.length; i++) {
            dfs(current.concat(nums[i]), i + 1);
        }
    }    
    return result;
};
-------------------------------------------------------------------------------------------
var subsets = function(nums) {
    var res = [[]]
    for (let i = 0; i < nums.length; i++) {
  		let length = res.length;
		for (let j = 0; j < length; j++) {
			res.push([...res[j],nums[i]])
        }  
   }
   return res
 };
//console.log(subsets([1,2,3]))
=======================================================================================================================================================================
Vowels of All Substrings:
var countVowels = function(word) {
    const vowels = new Set(['a', 'e', 'i', 'o', 'u']);
    let total = 0;
    let count = 0;
    for (let i = 0; i < word.length; i++) {
        if (vowels.has(word[i])) {
            count += i + 1;
        }
        total += count;
    }
    return total;
};
/*function countVowels(word) {
    let len = word.length;
    let vowels = ['a', 'e', 'i', 'o', 'u'];
    let count = 0;

    for (let i = 0; i < len; i++) {
        if (vowels.includes(word[i])) {
            count += len + (i * (len - i - 1));
        }
    }

    return count;
}*/
//console.log(countVowels("bac"))
/*var countVowels = function(word) {
  let total = 0;  
  for (let i = 0; i < word.length; i++) {
    if (['a','e','i','o','u'].includes(word[i])) {
      total += (i + 1) * (word.length - i);
    }
  }
  return total;
};*/
//console.log(countVowels("aba")) //6

/* The determinant factor of how many times a vowel will be used in the substring is depend on 2 things: the position of the vowel in the word and the remaining length of the word (from 0-indexed position of the vowel to end of the word)

  // So the formula is (0-indexed): `(i + 1) * (world.length - i)`, where `i` is the position of the vowel
  
  // Some example
  // Eg: 'abc'
  // - The letter 'a' in 0 place (0-indexed) is used 3 times, 'a', 'ab', 'abc'
  // Eg: 'bac'
  // - The letter 'a' in 1st place (0-indexed) is used 4 times, 'ba', 'bac', 'a', 'ac'
  // Eg: 'bca'
  // - The letter 'a' in 2nd place (0-indexed) is used 3 times, 'bca', 'ca', 'a'
 */
 ====================================================================================================================================================================
************************************ Permutations ***********************************
  
---------------------------------------- 1st Way ------------------------------------
var permute = function(nums) {
    let res = []
    function help(arr2){
        if (arr2.length==nums.length)
            return res.push(arr2)
        for(let e of nums)
            if (!arr2.includes(e))
                help([...arr2, e])
    }
    help([])
    return res
};
console.log(permute([1,2,3])) //[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
---------------------------------------- 2nd Way ------------------------------------
const permute = nums => {
    const arr = [];
    _permute(arr, [], nums);
    return arr;
};
const _permute = (arr, tempArr, nums) => {
    if (tempArr.length === nums.length) {
        //copy
        arr.push(tempArr.slice());
    } else {
        nums.map(n => {
        if (tempArr.indexOf(n) === -1) {
          tempArr.push(n);
          _permute(arr, tempArr, nums);
          tempArr.pop();
        }
      });
    }
};
---------------------------------------- 3rd Way ------------------------------------
var permute = function(letters) {
    let res = [];
    dfs(letters, [], Array(letters.length).fill(false), res);
    return res;
}
function dfs(letters, path, used, res) {
    if (path.length == letters.length) {
        // make a shallow copy since otherwise we'd be append the same list over and over
        res.push(Array.from(path));
        return;
    }
    for (let i = 0; i < letters.length; i++) {
        // skip used letters
        if (used[i]) continue;
        // add letter to permutation, mark letter as used
        path.push(letters[i]);
        used[i] = true;
        dfs(letters, path, used, res);
        // remove letter from permutation, mark letter as unused
        path.pop();
        used[i] = false;
    }
}
---------------------------------------- 4th Way ------------------------------------
var permute = function(nums) {
    let res = [];
    dfs(nums, new Set(), res);
    return res;
}
function dfs(nums, curr, res) {
    if (curr.size == nums.length) {
        res.push(Array.from(curr));
        return;
    }
    for (let i = 0; i < nums.length; i++) {
        if (curr.has(nums[i])) continue;
        curr.add(nums[i]);
        dfs(nums, curr, res);
        curr.delete(nums[i]);
    }
}
---------------------------------------- 5th Way ------------------------------------
const permute = (nums) => {
  const res = [];
  const go = (cur, rest) => {
    if (rest.length === 0) {
      res.push(cur);
      return;
    }
    for (let i = 0; i < rest.length; i++) {
      // note if using array push and splice here, it will cause mutation
      go(
        [...cur, rest[i]],
        [...rest.slice(0, i), ...rest.slice(i + 1)],
      );
    }
  };

  go([], nums);
  return res;
};
---------------------------------------- 6th Way ------------------------------------
var permute = function(nums) {
  let results = [];

  let permutations = (current, remaining) => {
    if(remaining.length <= 0) results.push(current.slice());
    else {
      for(let i = 0; i < remaining.length; i++) { // Loop through remaining elements
        current.push(remaining[i]); // Insert the iTH element onto the end of current
        permutations(current.slice(), remaining.slice(0, i).concat(remaining.slice(i+1))); 
        // Recurse with inserted element removed
        current.pop(); // Remove last inserted element for next iteration
      }
    }
  };

  permutations([], nums);
  return results;
};
---------------------------------------- 7th Way ------------------------------------
var permute = function(nums) {
    const result = [];    
    function traverse(nums, storeArr) {
        if(nums.length === 0) {
            result.push([...storeArr]);
            return ;
        }
        for(let num of nums) {
            storeArr.push(num);
            const value = nums.filter(item => item !== num);
            traverse(value, storeArr);
            storeArr.pop();
        }
    }    
    traverse([...nums], [])
    return result;
};
=========================================================================================================================================================================
Group Anagram: 
const groupAnagrams = strs => {
    const map = {};
    
    for (let str of strs) {
        const key = [...str].sort().join(''); //str.split('').sort().join('');

        if (!map[key]) { //creating a new key always for new
            map[key] = [];
        }

        map[key].push(str); //assgning values in the key
    }
    
    return Object.values(map);
}; 
console.log(groupAnagrams(["eat","tea","tan","ate","nat","bat"])) //[["bat"],["nat","tan"],["ate","eat","tea"]]
-------------------------------------
var groupAnagrams = function(strs) {
    let map = {}
    
    for (let str of strs) {
        let key = [...str].sort()
        map[key] = map[key] ? [...map[key], str] : [str]
    }
    
    return Object.values(map)
};
--------------------------------------
  Time complexity: O(m * n) where m is the total number of strings and n is the average number of char in each string
  Space complexity: O(n)
*/
var groupAnagrams = function(strs) {
  let result = {};
  for (let str of strs) {
    const keys = new Array(26).fill(0);
    for (let char of str) {
      keys[char.charCodeAt(0) - 97] += 1; 
    }
    
    if (!result[keys]) result[keys] = [];
    result[keys].push(str);
  }
  return Object.values(result);
}
console.log(groupAnagrams(["eat","tea","tan","ate","nat","bat"]))
======================================================================================================================================================================
 Remove All Adjacent Duplicates In String:
const removeDuplicates = s => {
  const stack = [];
  for (const char of s) {
    stack[stack.length - 1] === char ? stack.pop() : stack.push(char);
  }
  return stack.join('');
};
console.log(removeDuplicates("abbaca"))


Since we need to check and remove the previous char by the current char, so it let us think about the stack:

traverse the string s
for every char, we compare it with the top value in stack
if they are same, pop the top value
otherwise, push the current char into stack
finally, return the stack as a string
----------------------------------------------------------
var removeDuplicates = function(S) {
    let res = [];
    for(let i=0; i<S.length; i++){
        if(S[i] !== res[res.length-1]) {
            res.push(S[i]);
        } else {
            res.pop();
        }
    }
    return res.join("");
};
---------------------------------------------------------
var removeDuplicates = function(S) {
  let stack = [];
  stack.push(S[0]);
  for(let i=1; i<S.length; i++){
    if(S[i] != stack[stack.length - 1]){
        stack.push(S[i]);
    } else{
        stack.pop();
    }
  }
return stack.join("");
};
-----------------------------------------------------------
const removeDuplicates = (S) => S.match(/(.)\1/g) ? removeDuplicates(S.replace(/(.)\1/g, '')) : S;
==========================================================================================================================================================================
Reverse Words in a String
var reverseWords = function(s) {
  var arr = s.split(' ') , result = [];
  console.log("arr", arr)
  for(var i=arr.length; i>=0; i--){
     result.push(arr[i])
  }
  return result.filter(Boolean).join(" ");
};
//console.log(reverseWords("the sky is blue")) //"blue is sky the"
---------------------------------------------------------------------------------
const reverseWords = str => str.trim().split(/\s+/).reverse().join(' ');
---------------------------------------------------------------------------------
var reverseWords = function(str) {
    return str
            .split(' ')               //create an array of words separated based by spaces
            .filter(string => string) //remove empty strings to take care of extra whitespace
            .reverse()                //reverse the array of words
            .join(' ');               //join the words back together with spaces inbetween
};
---------------------------------------------------------------------------------
var reverseWords = function(s) {
    return s.split(' ').filter(word => word.length>0).reverse().join(' ')
};
---------------------------------------------------------------------------------
var reverseWords = function(s) {
    let words = s.split(" ").filter( x => x!='' );
    return words.reverse().join(' ');
};
==========================================================================================================================================================================
 Find Common Characters
 var commonChars = function(A) {
    const result = []
    const firstWordArr = [...A[0]]
    
    for(const letter of firstWordArr) {
        if(A.every(word => word.includes(letter))) { // // Every word in array has letter
            result.push(letter)
            A = A.map(word => word.replace(letter, ''))   // Remove the matched letter from the words
        }
    }    
    
    return result
};
console.log(commonChars(["cool","lock","cook"]))
-----------------------------------------------------------------------
var commonChars = function(A) {
    let common = A[0].split('').filter(char => {  //['c','o','o','k'] //c //o //o //k
        for (var i = 1; i < A.length; i++) { //iterate from index =1
            if (A[i].includes(char)) A[i] = A[i].replace(char, '');  
            else return false;
        }
        return true;
    })
	return common
};
//console.log(commonChars(["cool","lock","cook"]))
================================================================================================================================================================================
------------------------------------------------------------------------
