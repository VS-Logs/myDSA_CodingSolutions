<b>LeetCode Questions:</b>
Two Sum: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
Input: nums = [2,7,11,15], target = 9, Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
var twoSum = function(nums, target) {
    for(var i=0; i<nums.length; i++){
        for(var j=1; j<nums.length; j++){
            if(nums[i]+nums[j]==target){
                return [i,j] //[nums.indexOf(nums[i]),nums.indexOf(nums[j])]
            }
        }
    }    
};
------------------------------------------------------------------------------
var twoSum = function(nums, target) {
    const map = {};
    for(let i = 0; i < nums.length; i++){
        const diff = target - nums[i];
        if(map.hasOwnProperty(diff)){ //checking the new diff value is already present or not
           return [map[diff], i]; //[value, index]
		       break;
        }
        map[nums[i]] = i; //console.log(map) //we storing the exact value not diff
    }    
    return result;
};
console.log(twoSum([2,7,11,15], target = 9))
=========================================================================================================================================================================
Palindrome:
var isPalindrome = function(x) {
   if(x<0) return false;
   if(x.toString()===x.toString().split('').reverse().join('')) return true;
   return false;  
}
-------------------------------------------------------------------------------
var isPalindrome = function(x) {
   let len = x.length;
   if(x<0) return false;
    for (i=0; i<len/2;i++)
    {       
       if (x[i]!==x[len-1-i]) return false;  
    }
    return true;  
}
===========================================================================================================================================================================
Longest Common Prefix:
var longestCommonPrefix = function(strs) {
let ans = ""; var strs= strs.sort();
  for (i in strs[0]) { //i means 0,1,2
    if (!strs.every((el) => el[i] === strs[0][i])) { break; } 
      //every function return true/false usually //el representig each character of the items of 
      //an array which we are compairing with f,l,....
    ans += strs[0][i];
  }
  return ans;
};
--------------------------------------------------------------------------------
var longestCommonPrefix = function(strs) {
var arr = strs.sort()
  var i=0;
  while(arr[0].length>0 && arr[0].charAt(i)===arr[arr.length-1].charAt(i)){
    i++;
  }
  console.log(arr[0].substring(0,i)) 
  return arr[0].substring(0,i)
};
------------------------------------------------------------------------------
var longestCommonPrefix = function(strs) {
  if (strs.length === 0) return '';
  let r = '';
  for (let i = 0; i < strs[0].length; i++) {
    for (let j = 1; j < strs.length; j++) {
      if (strs[0][i] !== strs[j][i]) return r;
    }
    r += strs[0][i];
  }
  return r;
};
========================================================================================================================================================================
Valid Paranthesis :
var isValid = function(s) {
    let map ={
        "(":")",
        "{":"}",
        "[":"]"
    }
    let arr = []; //its example of stack i.e, 
    for (let ch of s){
        if(map[ch]){ //checking if inside in map object
            arr.push(map[ch]);
        }
        else if(arr.length>0 && arr[arr.length-1]===ch){ //checking length>0 otherwise give undefined
            arr.pop();
        }
        else {
            return false;
        }
    }
   return arr.length ===0 ? true: false;
};
--------------------------------------------------------------
const isValid = (s) => {
  const stack = [];
  for (const c of s) {
    if (c === '{' || c === '[' || c === '(') stack.push(c);
    else {
      const p = stack.pop(); // No need to check for empty before popping (returns undefined)
      if ((c === '}' && p !== '{') || (c === ']' && p !== '[') || (c === ')') & (p !== '(')) return false;
    }
  }
  return stack.length === 0; //true
};
=======================================================================================================================================================================
Contain duplicate: 
var containsDuplicate = function(nums) {
    return nums.length !== new Set(nums).size // As Set only contains non-duplicate values so new Set(nums) will remove all duplicates element then you can 
    //check if the lenght of the array is same as set if same means no duplicates element otherwise duplicate is there
};
---------------------------------------------------------------
var containsDuplicate = function(nums) {
    return nums.length > new Set(nums).size;
};
=========================================================================================================================================================================
Remove Duplicates from Sorted Array:
var removeDuplicates = function(nums) {
    let prev = null;
    const k = nums.length;
    for (let i = 0; i < k; i++) {
        if (prev === nums[i]) { //for duplicacy won't work
            continue;
        }
        prev = nums[i];
        nums.push(nums[i]); //[1,1,2,1,2]
    }
    nums.splice(0, k); //index, no. of elemnets from that index to delete the exact array
};
=========================================================================================================================================================================
Fibonacci Number:
const fib = N => {
    return (N < 2) 
        ? N 
        : fib(N-2) + fib(N-1);
};
------------------------------------------------------
const fib = n => {
    const memo = {};
    for (let i = 0; i <= n; i++)
    {
        if (i < 2)   memo[i] = i;
        else memo[i] = memo[i-2] + memo[i-1];
    }
    return memo[n];
}
------------------------------------------------------
const fib = n => {
    let arr = [0, 1];
    
    for (let i = 2; i <= n; i++) {
        arr.push(arr[i-2] + arr[i-1]);
    }
    
    return arr[n];
};
========================================================================================================================================================================
 Search Insert Position:
var searchInsert = function(nums, target) {
    for(let i=0; i<nums.length; i++) {
        if(target === nums[i] || target < nums[i]) { //  if (nums[i] >= target){
            return i
        }
    }
    
    return nums.length
};
---------------------------------------------------------------
var searchInsert = function(nums, target) {
    let start = 0;
    let end = nums.length - 1;
    while(start<=end) {
        const mid = Math.floor((start + end)/2);
        if(nums[mid] < target) {
            start = mid + 1;
        } else {
            end = mid -1;
        }   
    }
    return start;
};
console.log(searchInsert([1,2,4,5],3))
============================================================================================================================================================================
Roman To Integer:
var romanToInt = function(s) {
    const map = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000};
    let num = 0;   
    for(let i = 0; i < s.length; i++) {
        const curr = map[s[i]], next = map[s[i+1]];
        if(curr < next) num -= curr;
        else num += curr;
    }
    return num;    
};
console.log(romanToInt("LVIII"))
========================================================================================================================================================================
Valid Anagram:
var isAnagram = function(s, t) {
    if (s.length !== t.length) return false;
    return s.split("").sort().join("") === t.split("").sort().join("");
};
-------------------------------------------------------------------------
function isAnagram(s, t) {
  if (s.length !== t.length) return false;

  const map = {};

  for (let c of s) {
    if (map[c] == null) map[c] = 0;
    map[c]++;
  }

  for (let c of t) {
    if (map[c] > 0) map[c]--;
    else return false;
  }

  return true;
}
console.log(isAnagram("aman", "aamn"))
=======================================================================================================================================================================
Length of Last Word:-
var lengthOfLastWord = function(s) {
    const arr = s.trim().split(' ');
    return arr[arr.length - 1].length;
};
--------------------------------------------
var lengthOfLastWord = function(s) {
   return s.trim().split(" ").pop().length;
};
------------------------------------------
var lengthOfLastWord = function(s) {
   return s.trim().split(' ').at(-1).length;
};
----------------------------------------------
var lengthOfLastWord = function(s) {
    let len = 0;
    let hasStarted = false;
    for (let i = s.length - 1; i >= 0; i--) {
        if (s[i] !== ' ') hasStarted = true;
        if (hasStarted) {
            if (s[i] === ' ') break;
            len++;
        }
    }
    return len;
};
============================================================================================================================================================================
Majority Element:
var majorityElement = function(nums) {
    let map = {}
    for(let item of nums){
        if(!map[item]) {
            map[item] = 1;
        } else {
            map[item]++;
        }
        if (map[item] >= nums.length/2) return item
    }
};
========================================================================================================================================================================
Missing Number:
var missingNumber = function(nums) {
    nums.sort((a,b) => a - b ) 
    let count = 0
    for(let i = 0; i <= nums.length; i++) { // o (n)
        if(nums[i] == count) {
           count++
        } else {
            return count
        }
    }
};
------------------------------------------------
var missingNumber = function(nums) {
   nums.sort(function(a,b){return (a-b); });
    for(let i=0;i<nums.length;i++){
        if(nums[i]!==i){
            return i;
        }
    }
    return nums.length    
};
-----------------------------------------------
var missingNumber = function(nums) {
    nums.sort((a,b)=>a-b);
    if (nums[0] !== 0) return 0;
    for (var i = 0; i < nums.length; i++) {
        if (nums[i]+1 !== nums[i+1]) {
            return i+1;
        }
    }
};
==============================================================================================================================================================================
Reverse Vowels of a String:
var reverseVowels = function(s) {
    const VOWELS = { 'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1, 'A': 1, 'E': 1, 'I': 1, 'O': 1, 'U': 1 };
    const arr = s.split('');
    let i = 0, j = arr.length - 1;
    while (i < j) {
        if (VOWELS[arr[i]] && VOWELS[arr[j]]) { //if both present in VOWELS
            [arr[i], arr[j]] = [arr[j], arr[i]];
            i++;
            j--;
        } else if (VOWELS[arr[i]]) { //if left side present in VOWELS then need to find right hand side so that's why j--
            j--;
        } else { //if right side present in VOWELS
            i++;
        }
    }
    return arr.join('');
};
----------------------------------------------------------------------------
var reverseVowels = function(s) {
    let left = 0
    let right = s.length - 1
    let arr = s.split("")
    let vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', "I", 'O', 'U']
    
    while(left < right){
        if(vowels.indexOf(arr[left]) !== -1 && vowels.indexOf(arr[right]) !== -1) // if both present in vowels
            {
                [arr[left], arr[right]] = [arr[right], arr[left]]
                ++left;
                --right;
            }
        if(vowels.indexOf(arr[left]) == -1){ //if left not present
            ++left
        }
        if(vowels.indexOf(arr[right]) == -1){ //if right not prsent
            --right
        }
    }
    return arr.join("")
};
------------------------------------------------------------------------------------
const reverseVowels = (s) => {
    const vowels = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);
    s = s.split('');
    
    let l = 0, r = s.length - 1;
    
    while(l < r){
        if(vowels.has(s[l]) && vowels.has(s[r])){
            swap(s, l, r);
            l++, r--;
        }else if(!vowels.has(s[l])){
            l++;
        }else if(!vowels.has(s[r])){
            r--;
        }
    }
    
    return s.join('');
};

const swap = (arr, l, r) => {
    const temp = arr[l];
    arr[l] = arr[r];
    arr[r] = temp;
}
--------------------------------------------------------------------------
function swap(arr, idx1, idx2) {
    return [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
}

// reverse vowel function
var reverseVowels = function(s) {
    let vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'];
    s = s.split('');
    let start = 0;
    let end = s.length-1;
    while(start < end) {
        if(vowels.includes(s[start]) && vowels.includes(s[end])) {
            swap(s, start, end);
            start++;
            end--;
        }else if(!vowels.includes(s[start])){
            start++;
        } else if(!vowels.includes(s[end])) {
            end--;
        }
    }
    
    return s.join('');
};
================================================================================================================================================================================
Single Number:
var singleNumber = function(nums) {
            nums.sort();
            for (var i = 0; i < nums.length; i += 2) {
                if (nums[i] != nums[i + 1]) {
                    return nums[i];
                }
            }
};
-----------------------------------------
var singleNumber = function(nums) {
    let hash = {}
    for(let val of nums){
        hash[val]?delete hash[val]:hash[val]=1;
    }
    return Object.keys(hash)[0]
};
-----------------------------------------------
var singleNumber = function(nums) {
    for(var i=0;i<nums.length;i++) {
        if(nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])) return nums[i];
    }
};
===============================================================================================================================================================================
Fizz Buzz:
var fizzBuzz = function (n) {
  const result = [];
  for (let i = 1; i <= n; i++) {
    if (i % 5 === 0 && i % 3 === 0) result.push("FizzBuzz");
    else if (i % 3 === 0) result.push("Fizz");
    else if (i % 5 === 0) result.push("Buzz");
    else result.push(i.toString());
  }
  return result;
};
---------------------------------------------------------
var fizzBuzz = function (n) {
return new Array(n).fill(0).map((item, num) => (++num % 3 ? '' : 'Fizz') + (num % 5 ? '' : 'Buzz') || '' + num);
};

->My first thought is to use the Array constructor. If you pass an integer as the only argument, an empty array with the given length is returned.
-> for loop that goes from 0 — 100
-> This code makes use of the ternary operator(condition ? value if true : value if false).
-> The condition that we’re testing is ++i%3. 
    If that is true, then '' will be returned. 
    If ++i%3 is false, then fizz will be returned.
-> For ++i%3, the increment operator is being used. Using the operator before the operand ++i will increment the operator i before returning it. This means that on our first pass through the loop, i will increase from 0 to 1.
-> For 1 % 3, utilizes the remainder operator. The remainder operator returns the remainder of one number divided another.
-> The remainder is 1 and thus our ternary condition is now simplified to 1.
-> 1 ends up not being a falsy value and therefor coerces into a truthy value.
========================================================================================================================================================================
Concatenation of Array:
var getConcatenation = function(nums) {
    return nums.concat(nums)
};
--------------------------------------------------
var getConcatenation = function(nums) {
   return [...nums, ...nums]
};
--------------------------------------------------
var getConcatenation = function(nums) {
    var n = nums.length;
   for(var i=0; i<n; i++){
       nums[i+n]=nums[i]
   }
    return nums
}
--------------------------------------------------
var getConcatenation = function(nums) {
    let n = nums.length;
    let ans = new Array(2*n);    
    for(let i = 0; i < n; i++) {
		// ans[i] == nums[i] and ans[i + n] == nums[i]
        ans[i] = ans[i + n]= nums[i];
    }
    return ans;
};
=========================================================================================================================================================================
Sort Array By Parity: 
var sortArrayByParity = function(nums) {
    var even =[], odd=[];
    for(var i=0; i<nums.length;i++){
        if(nums[i]%2 ===0){ even.push(nums[i]) }  
        else {odd.push(nums[i])}
    }
    return even.concat(odd);
};
-----------------------------------------------------------
var sortArrayByParity = function(nums) {
    var even = nums.filter(num => num%2 === 0)
    var odd = nums.filter(num => num%2 !==0)
    return even.concat(odd);
}
------------------------------------------------------------
var sortArrayByParity = function(nums) {
    var even =[], odd=[];
    nums.forEach((item)=>{
         item%2==0 ? even.push(item) : odd.push(item)
        
    })
    return even.concat(odd)
}
---------------------------------------------------------------
var sortArrayByParity = function(nums) {
    var even =[], odd=[];
    nums.forEach((item)=>{
         item%2==0 ? even.push(item) : odd.push(item)        
    })
    return [...even, ...odd]
}
-------------------------------------------------------------
var sortArrayByParity = function(nums) {
    var temp =[]
    nums.forEach((item)=>{
         item%2==0 ? temp.unshift(item) : temp.push(item)        
    })
    return temp
}
-----------------------------------------------------------
var sortArrayByParity = function(A) {
    return [...A.filter(v => v % 2 === 0), ...A.filter(v => v % 2 !== 0)];
};
-----------------------------------------------------------
var sortArrayByParity = function(A) {
  let i = 0;
  let j = A.length -1;

  while(i < j) {
    if (A[i] % 2 !== 0 && A[j] % 2 === 0) {
      let temp = A[i];
      A[i] = A[j];
      A[j] = temp;
    }

    if (A[i] % 2 !== 0) {
      j--;
    }

    if(A[i] % 2 === 0) {
      i++;
    }
  }

  return A;
};
=========================================================================================================================================================================
String Compression: 
/*var compress = function(chars) {
    var arr=[], count=1;
    //if(chars.length===1) return 1;
    for(var i=0; i< chars.length; i++){
        if(!arr.includes(chars[i])){arr.push(chars[i])}
        if(chars[i] != chars[i+1]){
            arr.push(count);
          count =1;
        }
        if(chars[i]==chars[i+1]){
            count++;
        }
    }
    return arr.length;
};
//console.log(compress( ["a","b","b","b","b","b","b","b","b","b","b","b","b"]))
*/
------------------------------------------------------------------
var compress = function(chars) {
    var arr=[], count=1;
    if(chars.length===1) return 1;
    for(var i=0; i< chars.length; i++){
        if(!arr.includes(chars[i])){arr.push(chars[i])}
        if(chars[i] != chars[i+1]){
            arr.push(""+count);
          count =1;
        }
        if(chars[i]==chars[i+1]){
            count++;
        }
    }
    return arr.length;
};
console.log(compress( ["a","b","b","b","b","b","b","b","b","b","b","b","b"]))
======================================================================================================================================================================================
Find All Numbers Disappeared in an Array:
var findDisappearedNumbers = function(nums) {
    var s = {};
    for (let i =1; i<= nums.length; i++) {
        s[i] = 1; //storing all the key and values(1) to the object till the length of an array
    }    
    nums.forEach(n=> {   delete s[n] })  //deleting if we have in nums
   return Object.keys(s) //getting from an object
}; console.log(findDisappearedNumbers([4,3,2,7,8,2,3,1]))
-------------------------------------------------------------------
To find unique values:
var kthDistinct = function(arr) {
  var unique = []
  arr.filter((item)=>{
    if(!unique.includes(item))
       {
         unique.push(item)
       }
    else {
        unique.splice(1,1)
    }
  })
 
  return unique
};
console.log(kthDistinct(["d","b","c","b","c","a"])) //[d,a]
=====================================================================================================================================================================
 Kth Distinct String in an Array: 
var kthDistinct = function(arr,k) {
  var unique = []
  arr.filter((item)=>{
    if(!unique.includes(item))
       {
         unique.push(item)
       }
    else {
        unique.splice(1,1)
    }
  })
 
  return unique[k-1] == undefined ? "" : unique[k-1]
   
};
//console.log(kthDistinct(["d","b","c","b","c","a"],2))*/
-------------------------------------------------------------------------------
var kthDistinct = function(arr, k) {
    let obj = {}
    let ans = []
    
    for (let item of arr) {
        obj[item] = obj[item] + 1 || 1
    } // arr.forEach(letter => map[letter] = map[letter] + 1 || 1)
    
    for (let item in obj) {
        if (obj[item] === 1) {
            ans.push(item)   
        }
    }
    
    return ans.length >= k ? ans[k-1] : ''
    
    
};
-------------------------------------------------------------------------------
const kthDistinct = (arr, k) => {
    const map = {}
    
    for (const word of arr) {
        if (!(word in map)) map[word] = 0
        
        map[word]++
    }

    const distinct = arr.filter(word => map[word] === 1)
    
    return distinct[k - 1] || ''
}
-------------------------------------------------------------------------------
const kthDistinct = (arr, k) => {
  const notDistinct = new Set(arr.filter((x, index, arr) => arr.indexOf(x) !== arr.lastIndexOf(x)));
  return arr.filter((x) => !notDistinct.has(x))[k - 1] ?? "";
};
-------------------------------------------------------------------------------
var kthDistinct = function(arr, k) {
    let freqs = {};
    for (let s of arr) freqs[s] = (freqs[s] || 0) + 1;
       
    return [...Object.keys(freqs)].filter(x => freqs[x] === 1)[k - 1] || "";
};
======================================================================================================================================================================
Merge Strings Alternately:
var mergeAlternately = function(word1, word2) {
    var merged = [];
    var w1 = word1.split("");
    var w2 = word2.split("");
    for(var i=0; i<word1.length || i< word2.length; i++){
        merged.push(word1[i])
        if( word2[i]){
            merged.push(word2[i])
        }
    }
    return merged.join("")
};
console.log(mergeAlternately("abc","pqr"))
============================================================================
Divide a String Into Groups of Size k: 
var divideString = function(s, k, fill) {
    var result = []
    for(let i = 0;i<s.length;i+=k){
		const element = s.slice(i,i+k);
		if(element.length === k){
			result.push(element);
		}
		else {
			result.push(element+ fill.repeat(k - element.length));
			
		}
	}
	return result;
};
--------------------------------------------------------
var divideString = function(s, k, fill) {
    const res = []; let str = '';
    for (let i = 0; i < s.length; i++) {
        str += s[i];  
        if (str.length === k) {
            res.push(str);
            str = '';
        }
    }
    const n = str.length;   
    if (n > 0) {
        for (let i = 0; i < k - n; i++) {
            str += fill;
        }    
        res.push(str);
    }   
    return res;
};
console.log(divideString("abcdefghi", 3, "x"))
----------------------------------------------------------------
var divideString = function(s, k, fill) {
    let result = []    
    if(s.length % k !== 0) s = s.concat(fill.repeat(k - s.length % k))   
    for(let i = 0; i < s.length; i += k){
        result.push(s.slice(i,i+k))
    } 
    return result
};
------------------------------------------------------------------
const divideString = (s, k, fill) => {
  const result = []
  if (s.length % k) {
    s += fill.repeat(k - s.length % k)
  }
  for (let i = 0; i < s.length; i ++) {
    result.push(s.slice(i, i + k))
    i += k - 1
  }
  return result
}
=========================================================================================================================================================================
Plus One : 
var plusOne = function(digits) {
for(var i = digits.length - 1; i >= 0; i--){
     digits[i]++; 
    if(digits[i] > 9){
        digits[i] = 0;
    }else{
        return digits;
    }
}
digits.unshift(1);
return digits;
}; [1,2,3] //[1,2,4]
//First, I add 1 anyway. If there is a carry-over, the new digit will also add 1. If the current digit is less than 9 then return the array.
//Last, when running over for loop, I just put fill 1 in front of the array.
//the spread operator creates a copy while unshift manipulates the original array.
--------------------------------------------------------
var plusOne = function(digits) {
  for(let i = digits.length - 1; i >= 0; i --){
    if(digits[i] === 9){
      digits[i] = 0;
    }
    else {
      digits[i] ++;
      return digits; //if less than 9
    }
  }
  return [1,...digits] //[1, ...digits] is the equivalent of digits.unshift(1) //Always run for more than 9
  //this is used for the case where the digits are [9,9] after the iteration has //been completed, we are left with [0,0] which is wrong but it's okay because at //this point what we do is only increasing the number by one. So if this happens, //how do we return the right answer? We return the array with appending 1 in the //front and spread the digits to make a new array of [1,0,0]  
};
--------------------------------------------------
var plusOne = function(digits) {
    if (!digits || digits.length == 0) return [];
    for(let i = digits.length - 1; i >= 0; i--){
        if (digits[i] < 9){ //998->999  989->990
            digits[i]++;
            return digits;
        }
        else{
            digits[i] = 0;
        }
    }
    //only special case 999-> 1000
    let thousand = new Array(digits.length).fill(0);
    thousand.unshift(1); //add 1 in head of arr
    return thousand;
};
----------------------------------------------------------
var plusOne = function(digits) {
    let end = digits.length - 1;
    for(let i = end; i >= 0; i--){
        if(digits[i] !== 9){
            digits[i] = digits[i] + 1;
            break;
        } else {
            digits[i] = 0;
        }
    }

    if(digits[0] === 0) digits.unshift(1);
    return digits;
};
==========================================================================================================================================================================
Find First Palindromic String in the Array:
var firstPalindrome = function(words) {
    for(var i =0; i<words.length; i++){
        if(words[i] === words[i].split('').reverse().join('')){
           return words[i];
           break;
        }
    }
    return ""
};
----------------------------------------------------------------------
var firstPalindrome = function(words) {
    for (const word of words) {
        if (word === word.split('').reverse().join('')) return word;
    }
    
    return '';
}; 
----------------------------------------------------------------------
var firstPalindrome = function(words) {
    const isPalindrome = (w) => {
        if(w === w.split('').reverse().join('')) return true
        return false;
    }
    
    let result = words.find(word => isPalindrome(word));
    if(result) return result;
    return '';
};
----------------------------------------------------------------------
var firstPalindrome = function(words) {    
    let result = words.find(w =>w === w.split('').reverse().join('') ?  true :   false)
    return result ? result : '';
};
----------------------------------------------------------------------
const firstPalindrome = (words) => words.find((x) => x === [...x].reverse().join("")) ?? "";
----------------------------------------------------------------------
var firstPalindrome = function(words) {
    const palindrome = words.filter(item => item == item.split("").reverse().join(""));
    if (palindrome.length > 0){
      return palindrome[0];
    }
    return ""
}; 
----------------------------------------------------------------------
var firstPalindrome = function(words) {
  let reverseArr = []
   for(let i=0; i<words.length; i++){
       reverseArr.push(words[i].split('').reverse().join(''));
       if(reverseArr[i] == words[i]){
           return reverseArr[i]
       }
   }
   return ''
};
//console.log(firstPalindrome(["abc","car","ada","racecar","cool"])) //"ada"
=============================================================================================================================================================================
Count of Smaller Numbers After Self
var countSmaller = function(nums) {
    let newNums = [...nums];
    newNums.sort(function(i1, i2){return i1 - i2});    
    let res = [];
    for(let i = 0; i < nums.length; ++i){
        let seq = newNums.indexOf(nums[i]);
        res.push(seq);
        newNums.splice(seq, 1);
    }   
    return res; 
};
//console.log(countSmaller([5,2,6,1])) //[2,1,1,0]
----------------------------------------------------------
var countSmaller = function(nums) {
    if (nums.length === 0) return nums
    const retVal = []
    for (let i = 0; i < nums.length; i++) { // 1
        for (let j = 0; j < i; j++) { // 0
            if (nums[j] > nums[i]) { // 0 1
                retVal[j] += 1
            }
        }
        retVal.push(0)
    }
    return retVal;
};
===========================================================================================================================================================================
Add Strings:
var addStrings = function(num1, num2) {
    if(num1.length === num2.length){
    var result = (parseInt(num1)+parseInt(num2)).toString();}
    return result;
};
//console.log(addStrings("11", "123")) //"134"
----------------------------------------------------------------------------------
var addStrings = function(num1, num2) {
    var cast1 = num1 * 1
    var cast2 = num2 * 1
    var answer = cast1 + cast2;  
    return ''+answer;
};
----------------------------------------------------------------------------------
var addStrings = function(num1, num2) {
  const sum = BigInt(num1) + BigInt(num2);
  return sum.toString();
};
----------------------------------------------------------------------------------
var addStrings = function(num1, num2) {
    let len = num1.length>num2.length ? num1.length:num2.length;
    let l1 = num1.length-1, l2 = num2.length-1;
    let carry = 0, out = "", sum = 0;
    for(let i = 0; i<len; i++){
        sum = parseInt(num1[l1-i] || 0) + parseInt(num2[l2-i] || 0) + carry;
        out = sum%10 + out;
        carry = Math.floor(sum/10);
    }
    if(carry>0) out = carry+out;
    return out;
};
------------------------------------------------------------------------------------
var addStrings = function(num1, num2) {
    let result = "";
    let carry = 0;
    let p1 = num1.length - 1;
    let p2 = num2.length - 1;
    while(p1 >= 0 || p2 >= 0) {
        const x1 = p1 >= 0 ? (num1.charCodeAt(p1) - '0'.charCodeAt(0)) : 0;
        const x2 = p2 >= 0 ? (num2.charCodeAt(p2) - '0'.charCodeAt(0)) : 0;
        const value = (x1 + x2 + carry) % 10;
        carry = Math.floor((x1 + x2 + carry) / 10);
        result = value + result;   
        p1--;
        p2--;
    }
    if (!!carry) { result = carry + result}    
    return result;
};
==========================================================================================================================================================================
Find First and Last Position of Element in Sorted Array
function searchRange(nums, target) {
  return [nums.indexOf(target), nums.lastIndexOf(target)];
}
---------------------------------------------------------------
const searchRange = function(nums, target) {
	let index = nums.indexOf(target)

	if (index > -1) {
		let start = index
		let end = index
		while(nums[index] === nums[index + 1]) {
			end++
			index++
		}

		return [start, end]
	}

	return [-1, -1]
};
------------------------------------------------------------------
function binarySearch(nums, target, findMaxIndex) {
    let index = -1, start = 0, end = nums.length - 1;
    
    while (start <= end) {
        const mid = Math.floor(start + (end - start) / 2);
        if (target < nums[mid]) {
            end = mid - 1;
        } else if (target > nums[mid]) {
            start = mid + 1;
        } else {
            index = mid;
            if (findMaxIndex) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
    }
    
    return index;
}
var searchRange = function(nums, target) {
    const result = [-1, -1];
    
    result[0] = binarySearch(nums, target, false);
    if (result[0] > -1) {
        result[1] = binarySearch(nums, target, true);
    }
    
    return result;
};
---------------------------------------------------
var searchRange = function(nums, target) {
    var result = []
    for(var i=0; i<nums.length; i++){
        if(nums.length ==1 && nums[i]==target){
           return [0,0];
        }
        if(nums[i]===target){
         result.push(i)   
        }
    }
    return result.length ? result : [-1,-1];
};
//console.log(searchRange([5,7,7,8,8,10], 8)) //not worked for all test cases
=======================================================================================================================================================================
 Find the Difference:
 /**
 * @param {string} s
 * @param {string} t
 * @return {character}
 */
var findTheDifference = function(s, t) {
    return [...t].sort().find((char, i) => char !== [...s].sort()[i])
}; //s="abc", t="abcd"
/*var findTheDifference = function(s, t) {
    var sChars = s.split('').sort();
    var tChars = t.split('').sort();
    var i;
    for(i = 0; i < sChars.length; i++) {
        if(tChars[i] !== sChars[i]) {
            return tChars[i];
        }
    }
    return tChars[i];
};*/
/*var findTheDifference = function (s, t) {
    for (let i = 0; i < s.length; i++) {
        t = t.replace(s[i], '')
    }
    return t;
};*/
/*var findTheDifference = function(s, t) {
    for (let letter of s)
        t = t.replace(letter, '');
    return t;
};*/
/*var findTheDifference = function(s, t) {
  const sum1 = s.split('').reduce((acc, cur) => acc + cur.charCodeAt(0), 0);
  const sum2 = t.split('').reduce((acc, cur) => acc + cur.charCodeAt(0), 0);
  return String.fromCharCode(sum2 - sum1);
};*/


/*var findTheDifference = function(s, t) {
  var s = s.split("").sort((a,b)=> a-b).join(""); 
  var t = t.split("").sort((a,b)=> a-b).join("");
 // console.log(s,t)
  for(var i =0; i< t.length || s.length; i++){
      if(s[i] != t[i]){
          return t[i]
      }
  }
};
console.log(findTheDifference( "abcd", "abcde"))*/
====================================================================
String Matching in an Array:
var stringMatching = function(words) {
    words.sort((a, b) => a.length - b.length)
    const result = []
    
    for(let i=0; i<words.length; i++) {
        const currentWord = words[i]
        
        for(let j=i+1; j<words.length; j++) {
            if(words[j].includes(currentWord)) {
                result.push(currentWord)
                break
            }
        }
    }
    
    return result
};
/*var stringMatching = function(words) {
    let arr = []
    for(let i=0; i<words.length; i++){
       for(let j=0; j<words.length; j++){
        if(words[i] != words[j] && words[i].includes(words[j])){
            arr.push(words[j])
        }           
       }
    }
    let newArr = [...new Set(arr)]   // removed duplicate elements
    return newArr
};
/*var stringMatching = function(words) {
    let str = '';
    words.sort((a, b) => a.length - b.length);
    let res = [];
    for (let i = words.length - 1; i >= 0; i--) {
        if (str.includes(words[i])) res.push(words[i]);
        else str += words[i];
    } 
    
    return res;
};
/*const stringMatching = words =>
  words.filter(n => words.some(h => h !== n && h.includes(n)));
/*var stringMatching = function(words) {
    let res = [];
    for (let word of words){
        if (words.filter(w => w.includes(word)).length > 1) res.push(word);
    }
    return res;
};*/

//consle.log(stringMatching(["mass","as","hero","superhero"]))
========================================================================================================================================================================
Reorganize String:
var reorganizeString1 = function(S) {
    let hash = {};
    for (let c of S) hash[c] = hash[c] + 1 || 1;

    let sort = Object.keys(hash).sort((a,b)=>hash[b] - hash[a]);
    let res = [];
    let index = 0;

    for (let i = 0;i<sort.length;i++) {
        let occur = hash[sort[i]];
        if (occur > parseInt((S.length + 1)/2)) return "";
        for (let j = 0;j < occur;j++) {
            if (index >= S.length) index = 1;
            res[index] = sort[i];
            index += 2;
        }
    } 
    return res.join('');
};
console.log(reorganizeString("aab")) //"aba"
======================================================================================================================================================================
Longest Substring Without Repeating Characters: 
We can use the Sliding Window technique for this question. Sliding Window is good for analysing subsets within a data structure, to see which subset is the best. 
There are two approaches; fixed sized and dynamic. This solution uses the dynamic approach where the window is not a fixed size and can grow and shrink.
Sliding Window uses two pointers to define the boundary of the subset (this is the window). In this example left and i are the left and right pointers, respectively.
To solve the problem of finding the longest unique substring we use Set to store the characters. Before adding to the Set we first check if it already exists. 
If it does exist, we remove all the characters in the Set from the left (using our left pointer) until the duplicate character has been removed.

const lengthOfLongestSubstring = s => {
 //sliding window approach
 if(!s){return 0}
 let start=0, end=0;
 const uniqueCharacter = new Set();
 let maxLength=0;
 while(end<s.length){
     if(!uniqueCharacter.has(s[end])){
         uniqueCharacter.add(s[end]);
         end++;
         //maxLength = Math.max(maxLength, uniqueCharacter.size)
         maxLength = Math.max(maxLength, end - start )
     }
     else{
         uniqueCharacter.delete(s[start]);
         start++;
     }
 }
 return maxLength;
}
---------------------------------------
USING MAP:
var lengthOfLongestSubstring = function(s) {
    // keeps track of the most recent index of each letter.
    const seen = new Map();
    // keeps track of the starting index of the current substring.
    let start = 0;
    // keeps track of the maximum substring length.
    let maxLen = 0;
    
    for(let i = 0; i < s.length; i++) {
        // if the current char was seen, move the start to (1 + the last index of this char)
        // max prevents moving backward, 'start' can only move forward
        if(seen.has(s[i])) start = Math.max(seen.get(s[i]) + 1, start)
        seen.set(s[i], i);
        // maximum of the current substring length and maxLen
        maxLen = Math.max(i - start + 1, maxLen);
    } 
    
    return maxLen;  
};
---------------------------------------------------------------
using map:
const lengthOfLongestSubstring = (s) => {
    let tempMax = 0 
    let maxLen = 0;
    const map = new Map();     
    for(let i = 0; i < s.length; i++) { 
        const char = s[i];
        if (map.get(char) >= tempMax) { 
            tempMax = map.get(char) + 1; 
        }
        map.set(char, i); 
        maxLen = Math.max(maxLen, i - tempMax + 1) 
    }
    return maxLen
}
console.log(lengthOfLongestSubstring("abcabcbb"))

OR-----------------------------
const lengthOfLongestSubstring = (s) => {
    // reference to what is needed to update maxLen
    let tempMax = 0 
    // initalize at 0 
    let maxLen = 0;
    // use Map data structure due to ease of .get() and .set() methods 
    const map = new Map();   
  
    for(let i = 0; i < s.length; i++) { 
        const char = s[i]; 
      
        // check to see if character has been encountered before. if so, and the index was equal to or greater than the current tempMax, reset tempMax to index it was seen plus 1. 
        // important because if the index it was last seen is less than tempMax that means tempMax isn't incremented up, making it easier to use it to update our maxLen below
        // if it was encountered at a high index that means it will be harder to increase our maxLen since there is a repeat character pretty close to the current character
        // new characters don't result in tempMax being increased since the lookup returns undefined which will return false for the evaluation
        // this makes it easy for maxLen to be increased since that calculation looks at the index we are currently at which will always be pretty high since the loop always moves right
        if (map.get(char) >= tempMax) { 
            tempMax = map.get(char) + 1; 
        }

        // always update the index number we saw a character in the map 
        map.set(char, i); 
      
        // use tempMax to determine to update maxLen or not. adding 1 here offsets the addition of 1 when tempMax is recalculated
        // its used to determine if adding the current character is to our advantage or not as tempMax holds a reference to how far away our last repeat is
        // subtracting current index from how far away last repeat gives us that difference and the 1 says to update or not. note it has to be greater for it to be worth updating
        maxLen = Math.max(maxLen, i - tempMax + 1) 
    }

    return maxLen
}
=======================================================================================================================================================================

maxLength tracks the largest substring, after each iteration we set maxLength to itself or the size of the Set which ever is largest.
=======================================================================================================================================================================
Longest Palindromic Substring: 
var longestPalindrome = function(s) {
    let maxPal = '';
    
    for(let i = 0; i < s.length; i++) {
        bubble(i, i); // odd palindrome
        bubble(i, i+1); // even palindrome
    }
    
    function bubble(left, right) {

        while(left >= 0 && s[left] === s[right]) {
            left--;
            right++;
        }
        left++;
        right--;
        
        if(maxPal.length < right-left+1) {
            maxPal = s.slice(left, right+1)
        }
    }
    return maxPal;
};
---------------------------------------------------------------
var longestPalindrome = function(s) {
    let maxSub = '';
    
    const bubbleFromCenter = (left, right) => {
        while(left >= 0 && right < s.length && s[left] === s[right]) {
            left--;
            right++;
        }
        return s.slice(left+1, right)
    }
    
    for(let i = 0; i < s.length; i++) {
        const sub1 = bubbleFromCenter(i, i);
        const sub2 = bubbleFromCenter(i, i+1);
        const sub = sub1.length > sub2.length ? sub1 : sub2
        if(sub.length > maxSub.length) {
            maxSub = sub
        }
    }
    return maxSub
};
-----------------------------------------------------
var longestPalindrome = function(s) {
    let wonder = "";
    if (s === null || s.length === 0) return wonder;
    for (let i = 0; i < s.length; i++) {
        let tmpOne = calc(s, i, i);
        let tmpTwo = calc(s, i, i + 1);
        wonder = tmpOne.length > wonder.length ? tmpOne : wonder;
        wonder = tmpTwo.length > wonder.length ? tmpTwo : wonder;
    }
    return wonder;
};
    const calc = (s, left, right) => {
    while (left >= 0 && right < s.length && s[left] === s[right]) {
        left--;
        right++;
    }
    return s.substring(left + 1, right);  
};
---------------------------------------------------------------------
var longestPalindrome = function(s) {
    if(s.length<1 || s === null) return '';
    var longest = '';
    for(let i=0; i<s.length; i++){
        var oddCharacters = expandFromMid(s,i,i);
        var evenCharacters = expandFromMid(s,i-1, i);
        if(oddCharacters.length> longest.length){
            longest = oddCharacters
        }
        if(evenCharacters.length> longest.length){
            longest = evenCharacters
        }
    }
    return longest
};

const expandFromMid =(s, left, right)=>{
    var i=0;
    while(s[left-i] && s[left-i]===s[right+i]){
        i++;
    }
    i--;
   return s.slice(left-i, right+i+1)
}
//console.log(longestPalindrome("babad"))*/
=======================================================================================================================================================================
Valid Parentheses: 
var isValid = function(s) {
    if (s.length <=1) return false   
    let stack = []
    let hash = {
        '(' : ')',
        '[' : ']',
        '{' : '}'
    }  
    
   /* for(let i = 0; i < s.length; i++){
        if (hash[s[i]]) stack.push(hash[s[i]]) //s[i] means { //hash[s[i]] means }
        else if (s[i] !== stack.pop()) return false
    }
    return stack.length===0 ? true : false;*/
 
 
    /*for (let i = 0; i < s.length; i++) {
    if (s[i] === '(' || s[i] === '{' || s[i] === '[') {
      stack.push(s[i]);    
    } else if (hash[stack.pop()] !== s[i]) {
      return false;
    }
  }
  return stack.length ? false : true;*/


 /*for(const char of s) {
      if (char in hash) {
      stack.push(char);    
    } else if (hash[stack.pop()] !== char) {
      return false;
    }
  }
  return !stack.length */


  for (const c of s) {
    if (c === '{' || c === '[' || c === '(') stack.push(c);
    else {
      const p = stack.pop(); // No need to check for empty before popping (returns undefined)
      if ((c === '}' && p !== '{') || (c === ']' && p !== '[') || (c === ')') & (p !== '(')) return false;
    }
  }
  return stack.length === 0;


};
console.log(isValid("{}[]"))
============================================================================================================================================================================
Move Zeroes:
var moveZeroes = function(nums) {
 return  nums.sort((a,b)=> b-a)
};
console.log(moveZeroes([0,1,0,3,12])) //[12,3,1,0,0] //Don't prefer
------------------------------------------------
var moveZeroes = function(nums) {
 const nonEmpty =[], empty=[];
  for(var i=0; i< nums.length; i++){
    if(nums[i]!==0) nonEmpty.push(nums[i]);
    else empty.push(nums[i])
  }
 return nonEmpty.concat(empty); //[...nonEmpty, ...empty]
};
console.log(moveZeroes([0,1,0,3,12]))
-----------------------------------------------------
var moveZeroes = function(nums) {
  let j = 0  // nonzero count
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== 0) {	  
      [nums[j], nums[i]] = [nums[i], nums[j]] // swap elements
      j++
    }
  }
  return nums
};
console.log(moveZeroes([0,1,0,3,12]))
------------------------------------------------------
let moveZeroes = function(nums) {
        for(let i= nums.length-1; i>=0; i--){
            if(nums[i]===0){
                nums.push(0) //adding at last
                nums.splice(i,1) //removing that element
            }
        }
        return nums
    };
console.log(moveZeroes([10,1,0,3,12]))
---------------------------------------------------
const moveZeroes = function (numbers) {

   const nonZeroNumbers = numbers.filter(number => number !== 0);

   const amountOfZeros = numbers.length - nonZeroNumbers.length;

   nonZeroNumbers.push(...Array(amountOfZeros).fill(0))

   return nonZeroNumbers;

}
console.log(moveZeroes([0,1,0,3,12]))
====================================================================================================================================================================
Valid Palindrome:
var isPalindrome = function(s) {
    s = s.replace(/[^0-9a-zA-Z]+/gmi,""); //m means	Multiline: Anchor meta characters work on each line.
    s = s.toLowerCase();
    var l = 0, r = s.length - 1;
    console.log(s);
    while(l<r) {
        if(s.charAt(l) != s.charAt(r)) {
            return false;
        }
        l++;
        r--;
    }
    return true;
};
------------------------------------------------------------
var isPalindrome = function(s) {
    s = s.replace(/[^A-Za-z0-9]/g, '').toLowerCase(); 
    //[] means contain characters
    //^ means opposite
    // A-Za-z0-9 means All the characters in a-z, A-z, 0-9
    // g means global modifier 'g' to the regex to get all the matches
    for (let i = 0; i < s.length; i++) {
        if (s[i] !== s[s.length - 1 - i]) return false;
    }
    return true;
};
console.log(isPalindrome("A man, a plan, a canal: Panama"))// true
---------------------------------------------------------------
var isPalindrome = function(s) {
   // \w means	Matches alphanumeric characters: [a-zA-Z0-9_] 
   // \W	Matches non-alphanumeric characters: [^\w]
    s = s.replace(/[\W_]+/g,"");
    s = s.toLowerCase();
    var l = 0, r = s.length - 1;
  

    while(l<r) {
        if(s.charAt(l) != s.charAt(r)) {
            return false;
        }
        l++;
        r--;
    }
    return true;
}
------------------------------------------------------------------------
var isPalindrome = function(s) {
    // | means Alternation Matches either the characters before or the characters after the symbol.
    var strippedString = s.replace(/\W|_/g, '');
    var reversedString = strippedString.split('').reverse().join('');
    
    return strippedString.toLowerCase() == reversedString.toLowerCase();
};
------------------------------------------------------------------------------
var isPalindrome = function(str) {
    let s = str.toLowerCase().split('')
    for(let i=0;i<s.length;i++){
        if((s[i].charCodeAt(0) < 97 || s[i].charCodeAt(0) > 122) && (s[i].charCodeAt(0) < 48 || s[i].charCodeAt(0) > 57)){
            s[i]=' '
        }
    }
    let newS = ''
    for(let i=0;i<s.length;i++){
        if(s[i] !== ' '){
            newS+=s[i]
        }
    }
    return newS === newS.split('').reverse().join('')
};
===============================================================================================================================================================================
Subsets:    //https://www.youtube.com/watch?v=4paR1cZx9Tg&t=650s
var subsets = function(nums) {
    let res = []
    let subsets = []
	
    const dfs = (i) => {
        if (i >= nums.length) {
           res.push(subsets.slice()) 
           return
        }
        
        //include
        subsets.push(nums[i])
        dfs(i + 1)        
        subsets.pop()
        
        //exclude
        dfs(i + 1)
    }
	
    dfs(0)
    return res
};
-------------------------------------------------------------------------------------------
var subsets = function(nums) {
    let res = [[]];
    for (const num of nums) {
        const newRes = [];
        for (const sol of res) {
           newRes.push([...sol, num])
        }
        res = [...res, ...newRes];
    }
    
    return res;
};
-------------------------------------------------------------------------------------------
const subsets = nums => {
    let res = [[]],
        curr;
    for(let num of nums) {
        curr = res.map(x => [...x, num]);
        res = [...res, ...curr]; //addition of 2 arrays i.e res with curr
    }
    return res;
};
-------------------------------------------------------------------------------------------
var subsets = function (nums) {
	let finalOutput = [];
	const helper = (currentIndex, set) => { //0, []
		if (currentIndex >= nums.length) {
			finalOutput.push(set);
			return; 
		}
		helper(currentIndex + 1, [...set, nums[currentIndex]]);
        helper(currentIndex + 1, set);
	};
	helper(0, []);
	return finalOutput;
};
-------------------------------------------------------------------------------------------
var subsets = function(nums) {
    return nums.reduce((sets, num) => sets.forEach(set => sets.push([...set, num])) || sets, [[]]);
};
-------------------------------------------------------------------------------------------
var subsets = a => a.reduce((s, l) => s.concat(s.map(t => t.concat(l))), [[]]);
-------------------------------------------------------------------------------------------
var subsets = function(nums) {
    let result = [];
    dfs([], 0);    
    function dfs(current, index){
        result.push(current);
        for(let i = index; i < nums.length; i++) {
            dfs(current.concat(nums[i]), i + 1);
        }
    }    
    return result;
};
-------------------------------------------------------------------------------------------
var subsets = function(nums) {
    var res = [[]]
    for (let i = 0; i < nums.length; i++) {
  		let length = res.length;
		for (let j = 0; j < length; j++) {
			res.push([...res[j],nums[i]])
        }  
   }
   return res
 };
//console.log(subsets([1,2,3]))
=======================================================================================================================================================================
Vowels of All Substrings:
var countVowels = function(word) {
    const vowels = new Set(['a', 'e', 'i', 'o', 'u']);
    let total = 0;
    let count = 0;
    for (let i = 0; i < word.length; i++) {
        if (vowels.has(word[i])) {
            count += i + 1;
        }
        total += count;
    }
    return total;
};
/*function countVowels(word) {
    let len = word.length;
    let vowels = ['a', 'e', 'i', 'o', 'u'];
    let count = 0;

    for (let i = 0; i < len; i++) {
        if (vowels.includes(word[i])) {
            count += len + (i * (len - i - 1));
        }
    }

    return count;
}*/
//console.log(countVowels("bac"))
/*var countVowels = function(word) {
  let total = 0;  
  for (let i = 0; i < word.length; i++) {
    if (['a','e','i','o','u'].includes(word[i])) {
      total += (i + 1) * (word.length - i);
    }
  }
  return total;
};*/
//console.log(countVowels("aba")) //6

/* The determinant factor of how many times a vowel will be used in the substring is depend on 2 things: the position of the vowel in the word and the remaining length of the word (from 0-indexed position of the vowel to end of the word)

  // So the formula is (0-indexed): `(i + 1) * (world.length - i)`, where `i` is the position of the vowel
  
  // Some example
  // Eg: 'abc'
  // - The letter 'a' in 0 place (0-indexed) is used 3 times, 'a', 'ab', 'abc'
  // Eg: 'bac'
  // - The letter 'a' in 1st place (0-indexed) is used 4 times, 'ba', 'bac', 'a', 'ac'
  // Eg: 'bca'
  // - The letter 'a' in 2nd place (0-indexed) is used 3 times, 'bca', 'ca', 'a'
 */
 ====================================================================================================================================================================
************************************ Permutations ***********************************
  
---------------------------------------- 1st Way ------------------------------------
var permute = function(nums) {
    let res = []
    function help(arr2){
        if (arr2.length==nums.length)
            return res.push(arr2)
        for(let e of nums)
            if (!arr2.includes(e))
                help([...arr2, e])
    }
    help([])
    return res
};
console.log(permute([1,2,3])) //[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
---------------------------------------- 2nd Way ------------------------------------
const permute = nums => {
    const arr = [];
    _permute(arr, [], nums);
    return arr;
};
const _permute = (arr, tempArr, nums) => {
    if (tempArr.length === nums.length) {
        //copy
        arr.push(tempArr.slice());
    } else {
        nums.map(n => {
        if (tempArr.indexOf(n) === -1) {
          tempArr.push(n);
          _permute(arr, tempArr, nums);
          tempArr.pop();
        }
      });
    }
};
---------------------------------------- 3rd Way ------------------------------------
var permute = function(letters) {
    let res = [];
    dfs(letters, [], Array(letters.length).fill(false), res);
    return res;
}
function dfs(letters, path, used, res) {
    if (path.length == letters.length) {
        // make a shallow copy since otherwise we'd be append the same list over and over
        res.push(Array.from(path));
        return;
    }
    for (let i = 0; i < letters.length; i++) {
        // skip used letters
        if (used[i]) continue;
        // add letter to permutation, mark letter as used
        path.push(letters[i]);
        used[i] = true;
        dfs(letters, path, used, res);
        // remove letter from permutation, mark letter as unused
        path.pop();
        used[i] = false;
    }
}
---------------------------------------- 4th Way ------------------------------------
var permute = function(nums) {
    let res = [];
    dfs(nums, new Set(), res);
    return res;
}
function dfs(nums, curr, res) {
    if (curr.size == nums.length) {
        res.push(Array.from(curr));
        return;
    }
    for (let i = 0; i < nums.length; i++) {
        if (curr.has(nums[i])) continue;
        curr.add(nums[i]);
        dfs(nums, curr, res);
        curr.delete(nums[i]);
    }
}
---------------------------------------- 5th Way ------------------------------------
const permute = (nums) => {
  const res = [];
  const go = (cur, rest) => {
    if (rest.length === 0) {
      res.push(cur);
      return;
    }
    for (let i = 0; i < rest.length; i++) {
      // note if using array push and splice here, it will cause mutation
      go(
        [...cur, rest[i]],
        [...rest.slice(0, i), ...rest.slice(i + 1)],
      );
    }
  };

  go([], nums);
  return res;
};
---------------------------------------- 6th Way ------------------------------------
var permute = function(nums) {
  let results = [];

  let permutations = (current, remaining) => {
    if(remaining.length <= 0) results.push(current.slice());
    else {
      for(let i = 0; i < remaining.length; i++) { // Loop through remaining elements
        current.push(remaining[i]); // Insert the iTH element onto the end of current
        permutations(current.slice(), remaining.slice(0, i).concat(remaining.slice(i+1))); 
        // Recurse with inserted element removed
        current.pop(); // Remove last inserted element for next iteration
      }
    }
  };

  permutations([], nums);
  return results;
};
---------------------------------------- 7th Way ------------------------------------
var permute = function(nums) {
    const result = [];    
    function traverse(nums, storeArr) {
        if(nums.length === 0) {
            result.push([...storeArr]);
            return ;
        }
        for(let num of nums) {
            storeArr.push(num);
            const value = nums.filter(item => item !== num);
            traverse(value, storeArr);
            storeArr.pop();
        }
    }    
    traverse([...nums], [])
    return result;
};
=========================================================================================================================================================================
Group Anagram: 
const groupAnagrams = strs => {
    const map = {};
    
    for (let str of strs) {
        const key = [...str].sort().join(''); //str.split('').sort().join('');

        if (!map[key]) { //creating a new key always for new
            map[key] = [];
        }

        map[key].push(str); //assgning values in the key
    }
    
    return Object.values(map);
}; 
console.log(groupAnagrams(["eat","tea","tan","ate","nat","bat"])) //[["bat"],["nat","tan"],["ate","eat","tea"]]
-------------------------------------
var groupAnagrams = function(strs) {
    let map = {}
    
    for (let str of strs) {
        let key = [...str].sort()
        map[key] = map[key] ? [...map[key], str] : [str]
    }
    
    return Object.values(map)
};
--------------------------------------
  Time complexity: O(m * n) where m is the total number of strings and n is the average number of char in each string
  Space complexity: O(n)
*/
var groupAnagrams = function(strs) {
  let result = {};
  for (let str of strs) {
    const keys = new Array(26).fill(0);
    for (let char of str) {
      keys[char.charCodeAt(0) - 97] += 1; 
    }
    
    if (!result[keys]) result[keys] = [];
    result[keys].push(str);
  }
  return Object.values(result);
}
console.log(groupAnagrams(["eat","tea","tan","ate","nat","bat"]))
======================================================================================================================================================================
 Remove All Adjacent Duplicates In String:
const removeDuplicates = s => {
  const stack = [];
  for (const char of s) {
    stack[stack.length - 1] === char ? stack.pop() : stack.push(char);
  }
  return stack.join('');
};
console.log(removeDuplicates("abbaca"))


Since we need to check and remove the previous char by the current char, so it let us think about the stack:

traverse the string s
for every char, we compare it with the top value in stack
if they are same, pop the top value
otherwise, push the current char into stack
finally, return the stack as a string
----------------------------------------------------------
var removeDuplicates = function(S) {
    let res = [];
    for(let i=0; i<S.length; i++){
        if(S[i] !== res[res.length-1]) {
            res.push(S[i]);
        } else {
            res.pop();
        }
    }
    return res.join("");
};
---------------------------------------------------------
var removeDuplicates = function(S) {
  let stack = [];
  stack.push(S[0]);
  for(let i=1; i<S.length; i++){
    if(S[i] != stack[stack.length - 1]){
        stack.push(S[i]);
    } else{
        stack.pop();
    }
  }
return stack.join("");
};
-----------------------------------------------------------
const removeDuplicates = (S) => S.match(/(.)\1/g) ? removeDuplicates(S.replace(/(.)\1/g, '')) : S;
==========================================================================================================================================================================
Reverse Words in a String
var reverseWords = function(s) {
  var arr = s.split(' ') , result = [];
  console.log("arr", arr)
  for(var i=arr.length; i>=0; i--){
     result.push(arr[i])
  }
  return result.filter(Boolean).join(" ");
};
//console.log(reverseWords("the sky is blue")) //"blue is sky the"
---------------------------------------------------------------------------------
const reverseWords = str => str.trim().split(/\s+/).reverse().join(' ');
---------------------------------------------------------------------------------
var reverseWords = function(str) {
    return str
            .split(' ')               //create an array of words separated based by spaces
            .filter(string => string) //remove empty strings to take care of extra whitespace
            .reverse()                //reverse the array of words
            .join(' ');               //join the words back together with spaces inbetween
};
---------------------------------------------------------------------------------
var reverseWords = function(s) {
    return s.split(' ').filter(word => word.length>0).reverse().join(' ')
};
---------------------------------------------------------------------------------
var reverseWords = function(s) {
    let words = s.split(" ").filter( x => x!='' );
    return words.reverse().join(' ');
};
==========================================================================================================================================================================
 Find Common Characters
 var commonChars = function(A) {
    const result = []
    const firstWordArr = [...A[0]]
    
    for(const letter of firstWordArr) {
        if(A.every(word => word.includes(letter))) { // // Every word in array has letter
            result.push(letter)
            A = A.map(word => word.replace(letter, ''))   // Remove the matched letter from the words
        }
    }    
    
    return result
};
console.log(commonChars(["cool","lock","cook"]))
-----------------------------------------------------------------------
var commonChars = function(A) {
    let common = A[0].split('').filter(char => {  //['c','o','o','k'] //c //o //o //k
        for (var i = 1; i < A.length; i++) { //iterate from index =1
            if (A[i].includes(char)) A[i] = A[i].replace(char, '');  
            else return false;
        }
        return true;
    })
	return common
};
//console.log(commonChars(["cool","lock","cook"]))
================================================================================================================================================================================
Remove All Occurrences of a Substring:
var removeOccurrences = function(s, part) {
    const len = part.length;
    while(s.indexOf(part) !== -1) {
        s = s.slice(0, s.indexOf(part)) + s.slice(s.indexOf(part) + len) 
        //first slice to take first part of the string
        //second slice to take last part of the string
    }
    return s;
};
-----------------------------------------------------------------------------
const removeOccurrences = (s, part) =>	s.includes(part) ? removeOccurrences(s.replace(part, ''), part) : s;
-----------------------------------------------------------------------------
var removeOccurrences = function(s, part) {
    while(s.includes(part)){
        s=s.replace(part,'');
    }
    return s;
};
=======================================================================================================================================================================
Sort Characters By Frequency:
var frequencySort = function(s) {
    let map = {};
    for(let i = 0; i < s.length; i++) {
        map[s[i]] ? map[s[i]] += s[i] : map[s[i]] = s[i];
    }
    return Object.values(map).sort((a, b) => { return b.length - a.length }).join('');
};
//console.log(frequencySort("tree")) //"eert"
------------------------------------------------------------------
var frequencySort = function(s) {
    let map = {};
    for (var item of s){
        map[item] ? map[item] += [item] : map[item] = [item]
    }
    return Object.values(map).sort((a, b) => { return b.length - a.length }).join('');
};
console.log(frequencySort("tree"))
--------------------------------------------------------------------
var frequencySort = function(s) {
    let seen ={}; //{t: 1, r: 1, e: 2}
    for(let char of s){ // store characters Frequency of given string in map
        seen[char] ? seen[char]++ : seen[char]=1;
    }
    
    // sort characters according to characters Frequency in descending order
    let SortedCharactersArray = Object.keys(seen).sort((a,b)=>seen[b]-seen[a]); //[e,t,r]
    
    let result = ""
    // iterate through SortedCharactersArray and append character( character frequency )times to result  
    for(let char of SortedCharactersArray)
        result += char.repeat(seen[char]);
        //// repeat is a method where you input the number of occurrence. We just concatenate to result
    
    return result;
};
--------------------------------------------------------------------
var frequencySort = function(s) {
    return Object.values( s.split('').reduce((h,i) => {h[i] = (h[i]||'') + i; return h}, {}) ).sort((a,b) => b.length - a.length).join('')
};
=======================================================================================================================================================================
Split a String in Balanced Strings:
var balancedStringSplit = function(s) {
	let count = 0,
		balance = 0
	for (let i = 0; i < s.length; i ++) {
		if (s[i] === 'R') {
			balance ++
		} else {
			balance --
		}
		if (balance === 0) {
			count ++
		}
	}
	return count
};
console.log(balancedStringSplit("RLRRLLRLRL"))
-----------------------------------------------------
var balancedStringSplit = function(s) {
    let lcount = 0, rcount = 0;
    let count = 0;
    s.split('').forEach(val => {
        if(val==='R') rcount++;
        else if(val==='L') lcount++;
        if(lcount===rcount){
            count++;
            lcount = 0;
            rcount = 0;
        }
    });
    return count;    
};
------------------------------------------------------
var balancedStringSplit = function(s) {
    let balance = 0;
    let count = 0;
    s.split('').forEach(val => {
        if(val==='R') balance++;
        else if(val==='L') balance--;
        if(balance===0){
            count++;
        }
    });
    return count; 
};
---------------------------------------------------------
var balancedStringSplit = (s, count=0) => (s.
  split('').
  filter(element => { 
      (element == 'R' ? count += 1 : count -= 1); 
      return count == 0 }).
  length)
=========================================================================================================================================================================
3Sum :
var threeSum = function(nums) {
    let resultArr = [];
    const sortedArr = nums.sort((a, b) => a - b);
    for (i = 0; i < sortedArr.length - 2; i++) {
      if (sortedArr[i] > 0) {
        break;
      }
      if (i > 0 && sortedArr[i] === sortedArr[i - 1]) {
        continue;
      }
      let left = i + 1;
      let right = sortedArr.length - 1;
      while (left < right) {
        const sum = sortedArr[i] + sortedArr[left] + sortedArr[right];
        if (sum < 0) {
          left++;
        } else if (sum > 0) {
          right--;
        } else {
          resultArr.push([sortedArr[i], sortedArr[left], sortedArr[right]]);
          while(left < right && sortedArr[left] === sortedArr[left + 1]) {
            left++;
          }
          while(left < right && sortedArr[right] === sortedArr[right - 1]) {
            right--;
          }
          left++;
          right--;  
        }
      }
    }
    return resultArr;
};
/*-------------------------------------------------
var threeSum = function(nums) {
  nums.sort((a, b) => a - b);
  const r = [];
  for (let i = 0; i < nums.length - 2; i++) {
    if (nums[i] > 0) break;
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    let left = i + 1;
    let right = nums.length - 1;
    while (left < right) {
      const s = nums[i] + nums[left] + nums[right];
      if (s < 0) left ++;
      else if (s > 0) right --;
      else {
        r.push([nums[i], nums[left], nums[right]]);
        while (left < right && nums[left] === nums[left + 1]) left ++;
        while (left < right && nums[right] === nums[right - 1]) right --;
        left ++;
        right --;
      }
    }
  }
  
  return r;
};
---------------------------------------------------
var threeSum = function(nums) {
	nums.sort((a,b) => a-b)
	const result=[]

	if(nums.length < 3) return result

	for(let i=0; i< nums.length; i++){
		let left = i+1
		let right = nums.length-1
		if(i > 0 && nums[i] === nums[i-1]) continue
		while(left < right){
			let sum = nums[i] + nums[left] + nums[right]

			if(sum===0){
				let arr=[nums[i], nums[left], nums[right]]
				result.push(arr)
				left++
				while(nums[left] === nums[left-1] && left < right) left++
			}else if(sum > 0){
				right--
			}else{
				left++
			}
		}
	}

	return result
};
console.log(threeSum([-1,0,1,2,-1,-4]))
----------------------------------------------------
var threeSum = function(nums) {
  // First, let's sort the array. 
  // This gives us two benefits: 
  // 1. We can avoid duplicates, because skipping duplicate values in a sorted array is trivial (check if the prior value === current value)
  // 2. We can stop once we hit positive values, because no three positive values can be added to reach 0
  //
  // Finally, it's OK to sort, because we accept a quadratic runtime here,
  // and adding an O(logn) sort operation won't make that any worse
  nums.sort((a, b) => {
    return a - b
  })

  // With a sorted array, let's initialize a result array, which we'll use to hold our triplets
  const result = []

  // Now, loop through the sorted input array
  for (let i = 0; i < nums.length; i++) {

    // And if the number is greater than zero, 
    // that means the only have positive integers left in the sorted array,
    // and three positive integers will never equal 0,
    // so we're done with the input and can break.
    if (nums[i] > 0) {
      break;
    }

    // At each iteration, we want to make sure we skip duplicates,
    // so check that the prior number doesn't equal the current number.
    if (i > 0 && nums[i - 1] === nums[i]) {
      // If they're the same, skip this iteration
      continue;
    }

    // With the prior conditions satisfied, 
    // we can be certain we're looking at negative integers.
    // In which case, we want to find two integers further down the array, such that all three integers added together equals 0.
    //
    // Now we solve this with two pointers, which is how we would solve Two Sum II.
    // We use the sorted nature of the array to hone in on values that will equal zero.
    // 
    // Start the left pointer at the current index + 1, and the right pointer at the end of the array
    let left = i + 1
    let right = nums.length - 1

    while (left < right) {
      // Calculate the sum
      const sum = nums[i] + nums[left] + nums[right]

      // Check if the sum is equal to 0
      // if so, push nums[i], nums[left], and nums[right] to our top level result array
      if (sum === 0) {
        result.push([nums[i], nums[left], nums[right]])

        // Then, increment the left pointer and the right pointer, 
        // to see if there are any additional triplets that satisfy the conditions.
        left++
        right--

        // Also make sure we increment the left pointer past any possible duplicates
        while (left < right && nums[left] === nums[left - 1]) {
          left++
        }
      } else if (sum < 0) {
        // If the sum is less than zero, we want to see if we can increase it to hit zero. 
        // With a sorted input array, we can attempt this by incrementing the left pointer, 
        // to look at bigger numbers.
        left++
      } else {
        // Otherwise, sum is greater than zero, and we should try decreasing the sum, by decrementing the right pointer
        right--
      }
    }
  }

  return result
};*/
=====================================================================================================================================================================
Maximum Subarray : 
var maxSubArray = function(nums) {
	//Declare a variable for our current overall maximum sum
    let maxSum = nums[0];
	//Declare a temporary sum for comparison
    let tempSum = nums[0];
	//Iterate over nums starting at nums[1] since we set our initial sums to nums[0]
    for (let i = 1; i < nums.length; i++) {
		//The temporary sum is either the current number if the prior tempSum was negative for example
		//Or it is the sum of tempSum and the new sum if that figure is larger 
        tempSum = Math.max(nums[i], tempSum + nums[i]);
		//Every time we have a new tempSum we want to compare it to our running maxSum 
        maxSum = Math.max(tempSum, maxSum);
    };
	//return the max sum
  return maxSum;
};
----------------------------------------------------------
var maxSubArray = function(nums) {
    let max = -Infinity;
    let currentMax = 0;
    
    for(let i = 0; i < nums.length; i++) {
        currentMax = Math.max(nums[i], currentMax + nums[i]);
        max = Math.max(currentMax, max);               
    }
    
    return max;
};
------------------------------------------------------------
const maxSubArray = nums =>
  nums.reduce(
    ([localMax, globalMax], curr) => [
      Math.max(curr, localMax + curr),
      Math.max(curr, localMax + curr, globalMax),
    ],
    [-Infinity, -Infinity],
  )[1];
-------------------------------------------------------------
function maxSubArray(nums) {
    let subSum = nums[0]
    let max = nums[0]
    
    for(let i = 1; i < nums.length; i++) {
        // if the sum of the subarray is negative we're no longer interested and start summin again starting at the current value
        subSum = Math.max(subSum + nums[i], nums[i])

        // tracks the subarray with the highest sum found
        max = Math.max(subSum, max)
    }
    
    return max
};
-----------------------------------------------------------
var maxSubArray = function(nums) {
    let maxSum = nums[0];
    for (let i = 1; i < nums.length; i++) {
        if (nums[i - 1] > 0) {
            nums[i] += nums[i - 1];
        }
        maxSum = Math.max(nums[i], maxSum);
    }
    return maxSum;
};
---------------------------------------------------------------
var maxSubArray = function(nums) {
  for (let i = 1; i < nums.length; i++) {
    nums[i] = Math.max(nums[i], nums[i] + nums[i - 1]);
  }
  return Math.max(...nums)
};
console.log(maxSubArray([-2,1,-3,4,-1,2,1,-5,4]))
=========================================================================================================================================================================
Longest Common Subsequence (LCS):
var longestCommonSubsequence = function(text1, text2) { //using DP
    let dp = Array(text1.length + 1).fill(0).map(() => Array(text2.length + 1).fill(0))
    for (let i=0;i<text1.length; i++) {
        for (let j=0;j<text2.length; j++)
            dp[i+1][j+1] = text1[i] == text2[j]? dp[i][j]+1 : Math.max(dp[i][j+1],dp[i+1][j]);
    }
    return dp[text1.length][text2.length];
};
console.log(longestCommonSubsequence("abcde", "abc"))
-------------------------------------------------------------------------
var longestCommonSubsequence = function(text1, text2) { //using recursion
    const memo = new Map();
    return recursion(text1, text2, text1.length - 1, text2.length - 1, memo);
};

function recursion(text1, text2, index1, index2, memo) {
    // base cases
    if (index1 < 0 || index2 < 0) return 0;
    
    const key = index1 + '#' + index2;
    
    if (memo.has(key)) return memo.get(key);
    
    let result;

    if (text1.charAt(index1) === text2.charAt(index2)) {
        result = recursion(text1, text2, index1 - 1, index2 - 1, memo) + 1;
    } else {
        result = Math.max(recursion(text1, text2, index1, index2 - 1, memo), recursion(text1, text2, index1 - 1, index2, memo));
    }
    
    memo.set(key, result);
    return result;
}
------------------------------------------------------------------------
const lcs = (str1, str2, n, m, dp) => { //using recursion
    if (n==0 ||m==0) {
        return 0;
    }
    const key = n + ':' + m;
    if (dp.has(key)) {
        return dp.get(key);
    }
    if (str1[n-1] == str2[m-1]) {
        return 1+lcs(str1, str2, n-1,m-1, dp)
    }
    const lcsMax = Math.max(
        lcs(str1, str2, n-1, m, dp),
        lcs(str1, str2, n, m-1, dp)
    );
    dp.set(key, lcsMax);
    
    return dp.get(key);
    
}
var longestCommonSubsequence = function(text1, text2) {
    return lcs(text1,text2, text1.length, text2.length, new Map());
};
-------------------------------------------------------------------------
/*var longestCommonSubsequence = function(text1, text2) { //avoid to do this
    let count=0;
    var m = text1.split('');
    var n = text2.split('');
    for(var i=0; i< m.length && n.length<m.length; i++){
        for(var j=0; j< n.length ; j++){
            if(m[i]===n[j]){
                count++
            }
        }
    }
    return count
};*/

========================================================================================================================================================================
Generate Parentheses: 
var generateParenthesis = function(n) {
    let result = []

    backtracking('', n, n)

    function backtracking(temp, left, right) {
        if(left == 0 && right == 0) {
           result.push(temp)
        }
    
        if(left > 0) {
            backtracking(temp + '(', left-1, right)
        }
    
        if(right > left) {
            backtracking(temp + ')', left, right-1)
        }
    }
    return result
};
//console.log(generateParenthesis(3))
-----------------------------------------------------
var generateParenthesis = function(n) {
  var arr = [];
  compose(n, n, '');
  return arr;

  function compose(left, right, str) {
    if (!left && !right && str.length) return arr.push(str);
    if (left) compose(left - 1, right, str + '(');
    if (right > left) compose(left, right - 1, str + ')');
  }
};
input:3output:  ["((()))","(()())","(())()","()(())","()()()"]
-------------------------------------------------------------------------
var generateParenthesis = function(n) {
    //Create a list that will store the solution
    const sol = [];
    //Recursively call backtracking function
    generator(0, 0, "", sol, n);
    return sol;
};

function generator(op, cl, str, sol, n) {
        //Check the base case.
        //If number of opening and closing parentheses are equal to n..
        if(op === n && cl === n) {
            //add the string(str) to the list
            sol.push(str);
            return;
        }
        //if no. of opening parentheses(op) is less than n...
        if(op < n) {
            //add '(' to the current string and increment the count of opening parenthesis(op)
            generator(op + 1, cl, str + '(', sol, n);
        }
        //if no. of closing parentheses is less than open parentheses...
        if(cl < n && op > cl) {
            //add ')' to the current string and increment the count of closing parentheses(cl)
            generator(op, cl + 1, str + ')', sol, n);
        }
};
==========================================================================================================================================================================
Intersection of Two Arrays:
var intersection = function(nums1, nums2) {
  var result = nums1.filter((item)=>{
      return nums2.includes(item)
  })    
  return [...new Set(result)];
};
//console.log(intersection([1,2,2,1],[2,2]))
----------------------------------------------------
function intersection(nums1 , nums2){
    let setNum1 = new Set(nums1);
    return [...new Set(nums2.filter(num => setNum1.has(num)))];
}
----------------------------------------------------
var intersection = function(nums1, nums2) {
    let st1 = new Set(nums1);
    let st2 = new Set(nums2);

    let ans = [];
    
    st1.forEach(c => {
        if (st2.has(c)) {
            ans.push(c);
        }
    })
    
    return ans;
};
----------------------------------------------------
var intersection = function(nums1, nums2) {
  const set1 = new Set(nums1)
  const set2 = new Set(nums2)
  return [...set1].filter(n => set2.has(n))
};
----------------------------------------------------
var intersection = function(N1, N2) {
    return [...new Set(N1.filter(n => N2.indexOf(n) > -1))];
};
==========================================================================================================================================================================

/*var mySqrt = function(x) {
    let sqrt = 1;
    if(x===0){
        return 0;
    }
    for(let i=1; i*i<=x; i++){
      sqrt = i;
    }
    return sqrt;
};
-----------------------------------------
var mySqrt = function(x) {
    let val = 0;
    while((val * val) <= x) val++;
    return val - 1;
};
-----------------------------------------
var mySqrt = function(x) {
    let l = 0;
    let r = 94906265; // Math.floor(Math.sqrt(Number.MAX_SAFE_INTEGER));
    while (l <= r) {
        const m = Math.floor(l + (r - l) / 2);
        const m2 = m * m;
        if (m2 === x) {
            return m;
        } else if (x < m2) {
            r = m - 1;
        } else {
            l = m + 1;
        }
    }
    return r;
};
-----------------------------------------
Sqrt(x):- Input: 4 then output is 2
  var mySqrt = function(x) {
  var left = 1;
  var right = Math.floor(x / 2) + 1; ////Remember that the square root of each X must happen within [1, x/2 + 1]
  var mid;

  while (left <= right) {
    mid = Math.floor((left + right) / 2); 

    if (mid * mid > x) {
      right = mid - 1;
    } else if (mid * mid < x) {
      left = mid + 1;
    } else {
      return mid;
    }
  }

  return right;
};
============================================================================================================================================================================
Remove Linked List Elements: 
var removeElements = function(head, val) {
        if (head == null) return null;
        head.next = removeElements(head.next, val);
        return head.val == val ? head.next : head;
};
//For someone who finds it difficult to understand:

When the input node is an empty node, then there is nothing to delete, so we just return a null node back. (That's the first line)

When the head of the input node is the target we want to delete, we just return head.next instead of head to skip it. (That's the third line), else we will return head.

We apply the same thing to every other node until it reaches null. (That's the second line).
-------------------------------------------------
//https://www.youtube.com/watch?v=hSY49AuyQ2A
let removeElements = function(head, val) {
    let dummy=new ListNode(-1);
    dummy.next=head;
   let prev = dummy;
   let curr = head;
    while(curr){
        if(curr.val===val){
           prev.next = curr.next;
           curr = curr.next;          
        }
        else{
           prev =curr;
           curr = curr.next;           
        }
    }
    return dummy.next;  
};
console.log(removeElements([1,2,6,3,4,5,6],6)) //[1,2,3,4,5]
=========================================================================================================================================================================
Middle of the Linked List
/*
initial state
f
1 -> 2 -> 3 -> 4 -> 5
s

1st loop
		  f
1 -> 2 -> 3 -> 4 -> 5
     s
	 
2nd loop
		            f
1 -> 2 -> 3 -> 4 -> 5
          s

when f reach end of the linked list, s will be at the middle.

f = fast pointer
s = slow pointer
*/

var middleNode = function(head) {
    let fast = slow = head;
    while (fast && fast.next) {
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
};
console.log(middleNode([1,2,3,4,5]) //[3,4,5]
---------------------------------------------------------------------------------
var middleNode = function (head) {
    count = 0
    let copy = head
    while (head) {
        count += 1
        head = head.next
    }
    target = Math.floor(count / 2)
    count = 0
    while (count < target) {
        copy = copy.next
        count += 1
    }
    return copy
};
--------------------------------------------------------------------------
var middleNode = function(head) {
    let hi = head, cnt = 1;
    while (hi.next) {
        hi = hi.next;
        cnt++;
    }
    cnt = parseInt(cnt / 2);
    while (cnt--) {
        head = head.next;
    }
    return head;
};
-----------------------------------------------------------------------
var middleNode = function(head) {
    // Variables
    fast = head;
    slow = head;
    
    // While we have not reached the end of the linked list, have one pointer 'fast' move twice as fast as the slow pointer 'slow'. Once fast has reached the end of the list, 'slow' must therefore be in the middle of the list.
    while (fast?.next)
    {
        fast = fast.next.next;
        slow = slow.next;
    };
    
    //
    return slow;
};
------------------------------------------------------------------
var middleNode = function(head) {
    const values = [];
    
    let node = head;
    
    while (node) {
        values.push(node);
        node = node.next;
    }
    
    const i = Math.floor(values.length / 2);

    return values[i] || null;
};
==================================================================================================================================================================
Sort Array by Increasing Frequency:
var frequencySort = function(nums) {
  const hash={}
    for(let item of nums){
      hash[item] 
          ?hash[item]++
          :hash[item]=1
    }
 return nums.sort((a,b)=>hash[a]-hash[b]||b-a)   
    //or// return nums.sort((a, b) => map[a] === map[b] ? (b - a) : (map[a] - map[b]));
};
//console.log(frequencySort([1,1,2,2,2,3]))
-------------------------------------------------------
var frequencySort = function(nums) {
    let map = {}

    for(let num of nums) {
        if(!map[num]) {
            map[num] = 1
        } else {
            map[num]++
        }
    }

    let sortedArray = Object.entries(map).sort((a,b) => {
       if(a[1] == b[1]) { //1==2
           return b[0] - a[0]
       } else {
           return a[1] - b[1]
       }
    })
    console.log(sortedArray) //[["3", 1], ["1", 2], ["2", 3]]

    let result = []

    for(let arr of sortedArray) {
        while(arr[1] > 0) {
            result.push(+arr[0])
            arr[1]--
        }
    }

    return result;
};
console.log(frequencySort([1,1,2,2,2,3]))
--------------------------------------------------------
var frequencySort = function(nums) {
    let map = new Map()
    for (let n of nums) {
        map.set(n, (map.get(n) || 0)+1)
    }
    console.log(map)
    return nums.sort((a,b) => {
        if (map.get(a) === map.get(b)) return b - a
        return map.get(a) - map.get(b)
    })
};
console.log(frequencySort([1,1,2,2,2,3]))
=================================================================================================================================================================
Reverse Linked List: 
/*var reverseList = function(head) {
    let [prev, current] = [null, head]
    while(current) {
        [current.next, prev, current] = [prev, current, current.next] //one ack
    }
    return prev
}

prev   --->       curr  ---->     curr.next
   |-----------------------<----------------|
   
-------------------------------------------------

let reverseList = function(head) {
    let prev = null, next = null;
    while (head) {
        next = head.next
        head.next = prev;
        prev = head;
        head = next;
    }
    return prev;
};
----------------------------------------------------

var reverseList = function(head) {
    prev= null;
    while(head){
        [head.next, prev, head] = [prev, head, head.next]
    }
    
    return prev
};
----------------------------------------------------
*/
// Recursive solution
var reverseList = function(head, previous = null) {
    if (head === null) return previous;
    let next = head.next;
    head.next = previous;
    return reverseList(next, head);
};
======================================================================================================================================================================
Climbing Stairs:
/*var climbStairs = function(n) {
    let a = 1, b = 2, next;
    
    for(let i = 3; i <= n; i++) {
        next = a + b;
        a = b;
        b = next;
    }
    return n === 1 ? a : b;
};
-----------------------------------------
let climbStairs = function(n) {
    let arr=[];
    arr[1]=1;
    arr[2]=2;
    for(let i=3;i<=n;i++){
        arr[i]=arr[i-1]+arr[i-2];
    }
    return arr[n]; //the number of ways to reach stair n.
};
--------------------------------------
var climbStairs = function(n) {
    let memo = new Map();   
    let cs = (n) => {
        if(!memo.has(n)) {
            let res = (n < 2) ? 1 : cs(n-2) + cs(n-1);
            memo.set(n,res);      
        }
        return memo.get(n);
    }
    return cs(n)
};
--------------------------------------------
climbStairs = n =>
    Array(n - 1)
	    .fill(0) // Because the reduce function ignores undefined values.
        .reduce(([a, b]) => [b, a + b], [1, 1])
        .pop()
---------------------------------------------
*/
function climbStairs(n) {
    let cache = {};
    
    function helper(n) {
	   // base case
        if (n <=3 ) return n; 
		
		// place value in cache if not there
        if (cache[n] === undefined) {
            cache[n] = helper(n-1) + helper(n-2)
        }
		// always return the cached value to minimize duplicate computation
        return cache[n];
    }
    return helper(n);
};
===================================================================================================================================================================
Palindrome Linked List: Last way of the solution is best
/*var isPalindrome = function(head) {
    let node = head;
    let arr = [];
    while (node) {
        arr.push(node.val);
        node = node.next;
    }

    let reversedArr = arr.reverse();
    let index = 0;
    for (let i = reversedArr.length - 1; i >= 0; i--) {
        if (reversedArr[i] !== arr[index]) return false;
        index++;
    }
    
    return true 
};
------------------------------------------------------------
var isPalindrome = function(head) {
    let straight = '';
    let reversed = '';
    while (head) {
        straight = straight + head.val;
        reversed = head.val + reversed;    
        head = head.next;
    };
    return straight === reversed;
};
------------------------------------------------------------
var isPalindrome = function(head) {
    let arr=[];
    while (head){
        arr.push(head.val);
        head=head.next;
        }
    return arr.slice().reverse().join()==arr.join() ? true : false;
};
-------------------------------------------------------------
var isPalindrome = function(head) {
    let node = head
    let arr = []
    
    while(node){
        arr.push(node.val)
        node = node.next
    }
    
    return arr.join('') === arr.reverse().join('')
};
-----------------------------------------------------------
var isPalindrome = function(head) {
    const arr = [];
    while(head && head.val !== null) {
        arr.push(head.val);
        head = head.next;
    }
    return arr.every((e, i) => e === arr[arr.length - i - 1]);
};
--------------------------------------------------------------
var isPalindrome = function(head) {
    let arr=[]
    while(head !=null){
        arr.push(head.val)
        head=head.next
    }
    for(let i=0;i<arr.length/2;i++){
        
        if(arr[i]!==arr[arr.length-1-i] ){
            return false
        }
    }
    return true
    // return  arr.join('')===arr.reverse().join('')
};
----------------------------------------------------------
var isPalindrome = function(head) {
    if(head === null) return true
	
    let node = head
    const arr = []
    
    while(node) {
        arr.push(node.val);
        node = node.next;
        
    }
    
    let low = 0;
    let high = arr.length - 1;
	
    while(low < high) {
        if(arr[low] === arr[high]) {
            low++;
            high--;
        } else {
            return false;
        }
    }
    return true
};
------------------------------------------------------------
*/
//https://www.youtube.com/watch?v=LBD8rIjVxZI
function isPalindrome(head) {
  let fast = head;
  let slow = head;

  // Set slow at the head of the second half
  while (fast) {
    fast = fast.next ? fast.next.next : fast.next;
    slow = slow.next;
  }

  // Reverse the second half and returning prev
  let prev = null;
  while (slow) {
    const next = slow.next;
    slow.next = prev;
    prev = slow;
    slow = next;
  }

  // Compare the two halves in sequence if prev exist
  while (prev) {
    if (prev.val !== head.val) {
      return false;
    }
    prev = prev.next;
    head = head.next;
  }

  return true;
}
console.log(isPalindrome([1,2,2,1]))
====================================================================================================================================================================
Remove Duplicates from Sorted List
/*var deleteDuplicates = function(head) {
    var current = head;
    
    while(current) {
        if(current.next !== null && current.val == current.next.val) {
            current.next = current.next.next;
        } else {
            current = current.next;
        }
    }
    
    return head;
};
----------------------------------------------
var deleteDuplicates = function(head) {
  if (!head) return null;
  // Init prev as 1st node, next as 2nd node
  let prev = head, next = head.next;

  // Iterate until next is null, which is end of list
  while (next) {
    if (prev.val === next.val) {
	  // If next is a duplicate, skip over it by pointing its prev to its next
      prev.next = next.next;
    } else {
	  // Else, just move prev forward to continue through the list
      prev = prev.next;
    }
	// Always move next forward, it moves along with prev
    next = next.next;
  }

  return head;
}
-----------------------------------------------------------------
var deleteDuplicates = function(head) {
    // Special case...
    if(head == null || head.next == null)
        return head;
    // Initialize a pointer curr with the address of head node...
    let curr = head;
    // Traverse all element through a while loop if curr node and the next node of curr node are present...
    while( curr != null && curr.next != null){
        // If the value of curr is equal to the value of prev...
        // It means the value is present in the linked list...
        if(curr.val == curr.next.val){
            // Hence we do not need to include curr again in the linked list...
            // So we increment the value of curr...
            curr.next = curr.next.next;
        }
        // Otherwise, we increment the curr pointer...
        else{
            curr = curr.next; 
        }
    }
    return head;        // Return the sorted linked list without any duplicate element...
};
---------------------------------------------
var deleteDuplicates = function(head) {
  if(!head || !head.next) return head;
  head.next = deleteDuplicates(head.next);
  return head.val == head.next.val ? head.next : head;
};*/
========================================================================================================================================================================
Delete Node in a Linked List:
/*var deleteNode = function(node) { 
//WE DON'T DELETE THE NODE, WE ACTUALLY REPLACE THE VALUE OF THE NODE WITH THE NEXT //NODE VALUE AND THEN SKIP THE NODE
  //node.val is what we want to delete. It's 5 in the case of [4,5,1,9]
    //1. reassign the next nodes value (1) to this node (5). 
        //[4,1,1,9]
    //2. this node (1) will point to next next node (9) otherwise we would have 2 similar values of next node (1).
        //[4,1,1,9] => [4,1,9]
    node.val = node.next.val;
    node.next = node.next.next;  
};
console.log(deleteNode(5))//[4,5,1,9]
*/
=======================================================================================================================================================================
Remove Nth Node From End of List:
/*
https://www.youtube.com/watch?v=Q5AdN4nUuAg
https://www.youtube.com/watch?v=MzhI-u2h0-w
*/
/*var removeNthFromEnd = function(head, n) { //using 2 pointers
    let start = new ListNode()
    start.next = head
    let slow = start, fast = start
    for(let i=0; i<n; i++){
        fast = fast.next
    }
    while(fast.next){
        fast = fast.next
        slow = slow.next
    }
    slow.next = slow.next.next
    return start.next
};*/
/**old way*/
let removeNthFromEnd = function(head, n) {
    let fast = head, slow = head
    
    while(n--){ //placing the fast pointer so that diff(n) between slow and fast
        fast = fast.next
    }
    while(fast && fast.next ) { //it will go till last node
        fast = fast.next
        slow = slow.next
    }
    
    if(!fast)  head = head.next 
    else slow.next = slow.next.next

    return head
};
================================================================================================================================================================================
Odd Even Linked List:
/**
https://www.youtube.com/watch?v=ErkOfemuEuc
https://www.youtube.com/watch?v=zwr-YbD0D4A
 */
/*var oddEvenList = function(head) {
    if (!head || !head.next) return head;
    
    let odd = head, 
        even = head.next,
        evenhead = even;
    
    while (even !== null && even.next !== null) {
        odd = odd.next = even.next;
        even = even.next = odd.next;
    }
    odd.next = evenhead;
    return head;
};
--------------------------------------------
var oddEvenList = function(head) {
    if(head == null)return null;

    let odd = head;
    let even = head.next;
    let evenHead = even
    while(even?.next){
        odd.next = even.next;
        odd = odd.next;
        even.next = odd.next;
        even = even.next
    }
    odd.next = evenHead
    return head
};
-------------------------------------------
*/
var oddEvenList = function(head) {
    if(head != null){
        
        let odd = head, even = head.next, evenHead = even;
        
        while(even && even.next != null){
            odd.next = even.next;
		    odd = odd.next;
		    even.next = odd.next;
		    even = even.next;
        }
        odd.next = evenHead;
    }
    return head;
};
==========================================================================================================================================================================
Linked List Cycle:
/**
https://www.youtube.com/watch?v=wDgDAOVqhhA
*/

/*var hasCycle = function(head) {
    let fast = head;
    let slow = head;
    while (fast && fast.next) { //because it's not have a null. If we have null then give an error
        fast = fast.next.next;
        slow = slow.next;
        if (fast === slow) {
            return true;
        }
    }
    return false;
}
---------------------------------------------
var hasCycle = function(head) { 
    while (head) {
        if (head.visited) return true; //Mark a visit to a list node directly in the node.


        head.visited = true;
        head = head.next;
    }
    return false;
};
--------------------------------------------
var hasCycle = function(head) {
    let set = new Set();
    while (head) {
        if (set.has(head)) return true;
        set.add(head);
        head = head.next;
    }
    return false;
};
-------------------------------------------
var hasCycle = function(head) {
    let node = head;
    const stack = [];
    while (node && node.next) {
        if (stack.includes(node)) {
            return true;
        }
        stack.push(node)
        node = node.next;
    }
    return false;
};
-----------------------------------------------
*/
/*This solution iterates through every node, setting the value within the node to null. Since we know the values are integers by default, if we encounter one of these null values, we know that we have cycled back to a value we have already iterated over.*/

const hasCycle = (head) => {
  while (head) {
    if (!head.val) return true;

    head.val = null;
    head = head.next;
  }

  return false;
};
======================================================================================================================================================================
Merge Two Sorted Lists:
/**
https://www.youtube.com/watch?v=g_uxlc8C6HE
https://www.youtube.com/watch?v=W0Mwqk-uPsk
 */
/*var mergeTwoLists = function(l1, l2) {
    let dummyHead = new ListNode(0, null);
    let currentNode = dummyHead;
    
    while (l1 && l2) {
        if(l1.val < l2.val) 
        {
            currentNode.next = l1;
            l1 = l1.next
        } 
        else 
        {
            currentNode.next = l2;
            l2 = l2.next
        }
        currentNode = currentNode.next;
    }
    // It's possible that one linked list is shorter than the other so we just
	// add on the remainder of the last linked list. It's already sorted :)
    //currentNode.next = l1 || l2;
    if (l1 != null) currentNode.next = l1;
    if (l2 != null) currentNode.next = l2;
    
	// return .next because this first element in the linkedlist is empty
    
    return dummyHead.next;
};
------------------------------------------------------
var mergeTwoLists = function(l1, l2) {
    let node = new ListNode(-1);
    if (!l1 && !l2){
        return null;
    }
    else if (!l1 || !l2){
        return l1 || l2;
    }

    if (l1.val <= l2.val){
        node.val = l1.val;
        l1 = l1.next;
    } 
    else {
        node.val = l2.val;
        l2 = l2.next;
    }
    node.next = mergeTwoLists(l1, l2);
    return node;   
};
----------------------------------------------------
var mergeTwoLists = function(l1, l2) {
  if (!l1 || !l2 ) return l1 || l2
  if (l1.val > l2.val){
    [l1, l2] = [l2, l1]
  }
  l1.next = mergeTwoLists(l1.next, l2)
  return l1
};
----------------------------------------------------
*/
var mergeTwoLists = function(l1, l2) {
    if(!l1 || !l2) return l1 || l2
    if(l1.val < l2.val){
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
    }
    l2.next = mergeTwoLists(l1, l2.next)
    return l2
        
};
=======================================================================================================================================================================
Intersection of Two Arrays II:
/*const intersect = (nums1, nums2) =>
  nums1.filter(item => (
    nums2.includes(item)
      ? nums2.splice(nums2.indexOf(item), 1)
      : false
  ));
//console.log(intersect([1,2,2,1], [2,2]))
---------------------------------------------
const intersect = (nums1, nums2) => nums1.filter(n => nums2.includes(n) && nums2.splice(nums2.indexOf(n), 1));
----------------------------------------------
var intersect = function(nums1, nums2) {
    nums1.sort((a,b) => a-b)
    nums2.sort((a,b) => a-b)
    let arr = []
    let i=0, j=0
    while(i<nums1.length && j<nums2.length){
        if(nums1[i] < nums2[j]) i++
        else if(nums2[j] < nums1[i])    j++
        else{
            arr.push(nums1[i])
            i++
            j++
        }
    }
    return arr
};
-----------------------------------------------
var intersect = function(nums1, nums2) {
    
    const hash = {}, ar = []
    
    nums2.forEach(num => {
        hash[num] ? hash[num]++ : hash[num] = 1
    })
    
    for (let i = 0; i < nums1.length; i++){
        if (hash[nums1[i]] > 0){
            ar.push(nums1[i])
            hash[nums1[i]]--
        }
    }
    return ar
};
-------------------------------------------------
*/
const intersect = (n1, n2) => {
  const seen = {};
  const res = [];
  for (let n of n1) {
    if (!seen[n]) seen[n] = 0;
    seen[n]++;
  }

  for (let n of n2) {
    if (seen[n] > 0) {
      res.push(n);
      seen[n]--;
    }
  }
  return res;
};
=======================================================================================================================================================================
Best Time to Buy and Sell Stock:
/*var maxProfit = function(prices) {
    let result = 0;
    let min = prices[0];
    for(let i = 1; i < prices.length; i++) {
        min = Math.min(prices[i], min);
        result = Math.max(result, prices[i] - min); //profit = high-low
    }
    return result;
};
----------------------------------------
var maxProfit = function(prices) {
    let min = prices[0], max = 0;
    
    for(let i = 1; i < prices.length; i++){
        max = Math.max(prices[i] - min, max);
        min = Math.min(prices[i], min);
    }
    
    return max;
};
-------------------------------------------
var maxProfit = function(prices) {
    let maxProf = 0, curr = prices[0];
    
    for(let x of prices) {
        if(curr < x) maxProf = Math.max(maxProf, x - curr);
        else curr = x;
    }
    return maxProf;
};
----------------------------------------------
var maxProfit = function (prices) {
    let minBuyPrice = prices[0];
    let maxProfit = 0;
    for (let price of prices) {
        if (price < minBuyPrice) {
            minBuyPrice = price
        } else if (price-minBuyPrice > maxProfit){
            maxProfit = price-minBuyPrice
        }
    }
    return maxProfit
}
-------------------------------------------
function maxProfit(prices) { 
    let max = 0, min = Infinity;
    prices.forEach(price => price < min ? min = price : max = Math.max(max, price - min));
    return max;
};
-----------------------------------------
  var maxProfit = function(prices) {
    let max = 0;
    for (let i = 0; i < prices.length; i++) {
        for (let j = i + 1; j < prices.length; j++) {
            max = Math.max(max, prices[j] - prices[i]);
        }
     }
     return max;
  };
  --------------------------------------
  */
function maxProfit(prices) {
    let min = Number.MAX_SAFE_INTEGER; 

    return prices.reduce((max, price) => {
        min = Math.min(min, price);
        
        return Math.max(max, price - min);
    }, 0);
}
==========================================================================================================================================================================
Kth Largest Element in an Array:
var findKthLargest = function(nums, k) {
   nums.sort((a,b)=>b-a); //[6,5,4,3,2,1]
   return nums[k-1]
};
//console.log(findKthLargest([3,2,1,5,6,4],3))
==========================================================================================================================================================================
Container With Most Water:
/* https://www.youtube.com/watch?v=ZHQg07n_tbg
var maxArea = function(height) {
    let result = l = 0, r = height.length - 1, temp;
    while (l < r){
        temp = (r - l)   *   Math.min(height[l], height[r]); //breadth x length
        if (temp > result){
            result = temp;
        } 
        height[l] <= height[r] ? l ++: r --; //smaller or equal
    }
    return result;
};
------------------------------------------------------------
*/
const maxArea = heights => {
  let i = 0;
  let j = heights.length - 1;
  let water = 0;
  while (i < j) {
    water = Math.max(water, (j - i) * Math.min(heights[i], heights[j]));
    if (heights[i] < heights[j]) {
      i++;
    } else {
      j--;
    }
  }
  return water;
};
========================================================================================================================================================================

